{"meta":{"title":"Cheuk的博客","subtitle":null,"description":null,"author":"Cheuk","url":"http://diiyw.com","root":"/"},"pages":[{"title":"关于我","date":"2019-09-26T05:09:39.000Z","updated":"2021-05-25T09:59:36.095Z","comments":true,"path":"about/index.html","permalink":"http://diiyw.com/about/index.html","excerpt":"","text":"不知名服务端开发人员，业余级开源作者。"},{"title":"分类","date":"2019-09-22T06:56:44.000Z","updated":"2021-05-25T09:59:36.095Z","comments":true,"path":"categories/index.html","permalink":"http://diiyw.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-22T06:56:34.000Z","updated":"2021-05-25T09:59:36.099Z","comments":true,"path":"tags/index.html","permalink":"http://diiyw.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解Go的Channel (待更新)","slug":"inner-understanding-go-channels","date":"2021-05-01T01:51:24.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2021/05/01/inner-understanding-go-channels/","link":"","permalink":"http://diiyw.com/2021/05/01/inner-understanding-go-channels/","excerpt":"Go语言中通过goroutines和channel进行并发的控制。 goroutines 提供了独立任务的并发/并行可能 channel 提供goroutines间交流、同步的桥梁 理解Channel用法，参考这篇文章 《Go语言Channel的Buffered与Unbuffered》 ，总结channel有一下的特点： 保证goroutines并发安全 提供FIFO（先进先出）的特性 可以在goroutines传送和存储值 可以控制goroutines阻塞和非阻塞（控制执行和停止等待） 所以，我们需要从底层去了解channel的结构，channel 底层是一个hchan的数据结构： 123456789101112131415161718192021type hchan struct &#123; qcount uint // 队列数据总数 dataqsiz uint // 循环队列的大小 buf unsafe.Pointer // 指向dataqsiz大小的数组元素地址 elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // 发送索引 recvx uint // 接收索引 recvq waitq // 接收等待的队列 sendq waitq // 发送等待的队列 // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. // 锁 lock mutex&#125; 先不去关注具体的字段意义，我们从最基本的出发","text":"Go语言中通过goroutines和channel进行并发的控制。 goroutines 提供了独立任务的并发/并行可能 channel 提供goroutines间交流、同步的桥梁 理解Channel用法，参考这篇文章 《Go语言Channel的Buffered与Unbuffered》 ，总结channel有一下的特点： 保证goroutines并发安全 提供FIFO（先进先出）的特性 可以在goroutines传送和存储值 可以控制goroutines阻塞和非阻塞（控制执行和停止等待） 所以，我们需要从底层去了解channel的结构，channel 底层是一个hchan的数据结构： 123456789101112131415161718192021type hchan struct &#123; qcount uint // 队列数据总数 dataqsiz uint // 循环队列的大小 buf unsafe.Pointer // 指向dataqsiz大小的数组元素地址 elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // 发送索引 recvx uint // 接收索引 recvq waitq // 接收等待的队列 sendq waitq // 发送等待的队列 // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. // 锁 lock mutex&#125; 先不去关注具体的字段意义，我们从最基本的出发 创建channel1ch := make(chan int, 3)","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://diiyw.com/categories/Go语言/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://diiyw.com/tags/Go/"}]},{"title":"Go的坑点记录 （持续记录）","slug":"go-special-pit","date":"2021-04-27T18:55:03.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2021/04/27/go-special-pit/","link":"","permalink":"http://diiyw.com/2021/04/27/go-special-pit/","excerpt":"Go的变量传参是值传递这边文章有具体分析：《Go语言参数传递是传值还是传引用》,看一段代码： 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; var i = make([]int, 3) foo(i) fmt.Println(i) boo(i) // 没有输出 1 0 0 3 4 5 fmt.Println(i)&#125;func foo(s []int) &#123; s[0] = 1&#125;func boo(s []int) &#123; s = append(s, 3, 4, 5)&#125; 输出： 12[1 0 0][1 0 0]","text":"Go的变量传参是值传递这边文章有具体分析：《Go语言参数传递是传值还是传引用》,看一段代码： 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; var i = make([]int, 3) foo(i) fmt.Println(i) boo(i) // 没有输出 1 0 0 3 4 5 fmt.Println(i)&#125;func foo(s []int) &#123; s[0] = 1&#125;func boo(s []int) &#123; s = append(s, 3, 4, 5)&#125; 输出： 12[1 0 0][1 0 0] 第二段输出并不是[1 0 0 3 4 5]，切片是引用类型，但是并不是引用传递。Go底层中如果切片没有扩容，修改的结果将应用到原值。12345678910111213141516171819202122232425262728293031323334353637383940## Defer 中包含panic，panic仅有最后一个可以被revover捕获示例代码：```gopackage mainimport ( &quot;fmt&quot;)func main() &#123; defer func() &#123; // 无法被捕获 panic(&quot;defer panic 1&quot;) &#125;() defer func() &#123; if err := recover(); err != nil&#123; fmt.Println(&quot;receive: &quot;,err) &#125;else &#123; fmt.Println(&quot;fatal&quot;) &#125; &#125;() defer func() &#123; // 被recover捕获 panic(&quot;defer panic 2&quot;) &#125;() defer func() &#123; panic(&quot;defer panic 3&quot;) &#125;() // 这里的会被替换 panic(&quot;panic here&quot;)&#125; defer的执行顺序是先进后出。输出： 12345678receive: defer panic 2panic: defer panic 1goroutine 1 [running]:main.main.func1() /Users/xxx/workspace/testing/go/main.go:11 +0x39main.main() /Users/xxx/workspace/testing/go/main.go:32 +0x99 触发panic(&quot;panic&quot;)后defer顺序出栈执行，第一个被执行的defer中 会有panic(&quot;defer panic 3&quot;)异常语句，这个异常将会覆盖掉main中的异常panic(&quot;panic&quot;)，第三个defer会替换掉panic(“defer panic 3”)，这个异常被第二个执行的defer捕获到。第一个无法被捕获程序崩溃。 Go中可以调用类型赋值为nil的属性方法123456789101112131415161718package mainimport \"fmt\"type Foo struct &#123;&#125;func (f *Foo) A() &#123; fmt.Println(\"A\")&#125;func main() &#123; var f = new(Foo) fmt.Println(f) f = nil f.A()&#125; 正常输出： 12&amp;&#123;&#125;A 程序并不会奔溃。这事什么原因呢？Google中找到一段说明 In Go the function to be called by the Expression.Name() syntax is entirely determined by the type of Expression and not by the particular run-time value of that expression, including nil. 对象方法是不在运行时确定的（编译时已经确定），所以运行时对象的nil，并不会导致panic; struct{} 是个空类型struct{} 是个空类型，所有struct{} 指向同一个零地址，可以用于channel的信号传送 12345678910111213package mainimport \"fmt\"type foo1 struct&#123;&#125;type foo2 struct&#123;&#125;func main() &#123; f1 := new(foo1) f2 := new(foo2) fmt.Printf(\"%p\\n\", f1) fmt.Printf(\"%p\", f2)&#125; 无论执行多少次，同台电脑都会输出相同的值 120x118e3700x118e370 不要用共享内存进行协程通讯12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"time\")func main() &#123; you := \"bar are you\" foo := \"foo\" str := \"\" go func() &#123; flag := false for &#123; if flag &#123; str = you &#125; else &#123; str = foo &#125; flag = !flag time.Sleep(5 * time.Millisecond) &#125; &#125;() for &#123; if str == \"bar\" &#123; panic(\"bar\") &#125; fmt.Println(str) time.Sleep(5 * time.Millisecond) &#125;&#125; 该代码运行一段时间后，会panic. 说明string 类型其实不是线程安全的。str内部结构包含len、data 两个字段，先修改了data，在没有修改len情况下，取值将取的是str的len长度的字符串，所以上述代码会panic。当然这也违背了Go语言：”不要通过共享内存来通信，而应该通过通信来共享内存”。","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://diiyw.com/categories/Go语言/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://diiyw.com/tags/Golang/"}]},{"title":"Lumen/Laravel Model 操作","slug":"lumen-model-tutorials","date":"2020-11-10T03:20:15.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2020/11/10/lumen-model-tutorials/","link":"","permalink":"http://diiyw.com/2020/11/10/lumen-model-tutorials/","excerpt":"简介Lumen的Model操作使用的是 Laravel 内置的 Eloquent ORM，Eloquent提供了一个美观、简单的与数据库打交道的 ActiveRecord 实现，每张数据表都对应一个与该表进行交互的模型（Model），通过模型类，你可以对数据表进行查询、插入、更新、删除等操作。 配置应用的数据库配置位于 config/database.php（但是数据库用户及密码等敏感信息位于 .env 文件）。在该文件中你可以定义所有的数据库连接，并指定哪个连接是默认连接。该文件中提供了所有支持数据库系统的配置示例。 1env('DB_CONNECTION', 'mysql') // 配置文件中通过env()获取.env文件中配置的键值","text":"简介Lumen的Model操作使用的是 Laravel 内置的 Eloquent ORM，Eloquent提供了一个美观、简单的与数据库打交道的 ActiveRecord 实现，每张数据表都对应一个与该表进行交互的模型（Model），通过模型类，你可以对数据表进行查询、插入、更新、删除等操作。 配置应用的数据库配置位于 config/database.php（但是数据库用户及密码等敏感信息位于 .env 文件）。在该文件中你可以定义所有的数据库连接，并指定哪个连接是默认连接。该文件中提供了所有支持数据库系统的配置示例。 1env('DB_CONNECTION', 'mysql') // 配置文件中通过env()获取.env文件中配置的键值 模型定义模型定义的目录app\\Models 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class TestModel extends Model&#123; // 指定连接名称 // config/databases.php中的mysql索引项。 protected $connection = \"mysql\" // 定义表名 protected $table = \"test\"; // 定义默认主键，默认是id，如果是其他值这里需要修改 protected $primaryKey = \"id\"; // 这里是主键的类型，默认int如果是非int类型就需要修改 protected $keyType = 'int'; // 主键是否是自增的配置 public $incrementing = true; // 表明模型是否应该被打上时间戳，这个功能可以让ORM自动为我们的时间字段自动更新配置上时间 // 配合CREATED_AT 使用 UPDATED_AT使用 // 默认开启，如果不实用该功能配置false public $timestamps = false; // CREATED_AT、UPDATED_AT配置常量可以自定义自己的字段名称 const CREATED_AT = 'created_at'; const UPDATED_AT = 'updated_at'; // 当然也可以指定保存的时间格式 // 这里可接受的值跟date()的接受的值是一致的。 // 文档 https://www.php.net/manual/zh/function.date.php protected $dateFormat = 'U';&#125; 模型CRUD查询在Contoller，Service层等可以直接调用模型方法 获取全部数据all()返回所有数据，如果数据存在返回对象\\Illuminate\\Database\\Eloquent\\Collection 可以使用toArray()方法输出为数组格式。如果没有数据放回空数组。 12$data = TestModel::all();$data-&gt;toArray(); 获取一条数据first() 如果找到了数据返回的是个对象, 可以使用toArray()方法输出为数组格式，如果找不到数据返回null; 12$data = TestModel::first();$data-&gt;toArray(); 获取多条数据注意： 无论查询结果是否为空，get()方法都放回一个对象，如果使用empty() 检测一定都是false;所以可以完全直接调用toArray()，这一点和first()是不一样的。 12$data = TestModel::get();$data-&gt;toArray(); 注意： 如果对结果集对象遍历 1234&lt;?php foreach($data as $v) &#123; // 这里的$v是个stdClass对象 &#125; 查询指定字段123$data = TestModel::select(\"name\")-&gt;first();// 多个字段$data = TestModel::select(\"name\",\"status\")-&gt;first(); 如果要对字段进行表达式处理 1234// 多个字段$data = TestModel::selectRaw(\"name,status\")-&gt;first();// 复杂查询$data = TestModel::selectRaw(\"CASE name WHEN 1 THEN 1 ELSE -1 END name\")-&gt;first(); Where条件where条件大都封装好了，可以使用whereXXX()调用，如whereIn()、whereBetween。 12345678910111213141516$data = TestModel::select(\"name\")-&gt;where(\"status\",1)-&gt;first();// 或者$data = TestModel::select(\"name\")-&gt;where(\"status\",\"=\",1)-&gt;first();// in 查询$data = TestModel::select(\"name\")-&gt;whereIn(\"status\",[1,-1])-&gt;first();// between// select name from `test` where `status` = ? and `status` between ? and ?$data = TestModel::select(\"name\")-&gt;where(\"name\",\"hello\")-&gt;whereBetween(\"status\",[1,-1])-&gt;first();// between // select name from `test` where `status` = ? or `status` between ? and ?$data = TestModel::select(\"name\")-&gt;where(\"name\",\"hello\")-&gt;whereBetween(\"status\",[1,-1],\"or\")-&gt;first();// between // select name from `test` where `status` = ? or `status` not between ? and ?$data = TestModel::select(\"name\")-&gt;where(\"name\",\"hello\")-&gt;whereBetween(\"status\",[1,-1],\"or\",true)-&gt;first();// or $data = TestModel::select(\"name\")-&gt;orWhere(\"status\",\"=\",1)-&gt;first(); 分页123$data = TestModel::select(\"name\")-&gt;orWhere(\"status\",\"=\",1)-&gt;offset(0)-&gt;limit(10)-&gt;get();// 或者$data = TestModel::select(\"name\")-&gt;orWhere(\"status\",\"=\",1)-&gt;skip(10)-&gt;limit(10)-&gt;get(); 自动分页Eloquent ORM 内置一个非常方便的自动分页处理函数。 12// 只要传入每页条数， Eloquent自动帮你处理分页数据。指定页数是参数`page`可以修改自己的名称。$users = TestModel::select(\"name\")-&gt;paginate(10); $users是一个分页对象，可以使用 appends 方法增加搜索字串到分页链接中： 1$users-&gt;appends(['sort' =&gt; 'votes']); 这样会产生类似下列的链接： 1http://example.com/something?page=2&amp;sort=votes 如果您想要将「哈希片段」加到分页的 URL，您可以使用 fragment 方法： 1$users-&gt;fragment('foo'); 此方法调用后将产生 URL，看起来像这样： 1http://example.com/something?page=2#foo setPath 方法自定义使用的 URL： 1$users-&gt;setPath('http://domain/path'); Join连表查询1$data = TestModel::select(\"name\")-&gt;leftJoin(\"user\",\"user.id\",\"=\",\"test.id\")-&gt;first(); Count等聚合查询直接返回整型数。 12TestModel::count();TestModel::max(\"price\"); 分组与排序12$data = TestModel::orderBy(\"id\",\"desc\")-&gt;first();$data = TestModel::orderBy(\"id\",\"desc\")-&gt;groupBy(\"city\")-&gt;first(); 执行原生语句1234// 这个方法返回一个二维数组、数组元素是一个stdClass对象。查询不到数据返回空数组。DB::connection(\"mysql\")-&gt;select(\"select * from user where status=? limit 1\",[1]);// 或者，返回与上面的一致$data = (new TestModel())-&gt;getConnection()-&gt;select(\"select * from user where status=? limit 1\",[1]); 插入1234// 返回布尔值，成功或者失败 $success = TestModel::insert([\"namae\" =&gt; \"john\"]);// 返回自增ID的值$id = TestModel::insertGetId([\"namae\" =&gt; \"john\"]); 更新1234567// 返回受影响的行数$rowEffect = TestModel::where(\"id\",1)-&gt;update([\"status\"=&gt;1]);// 或者$model = TestModel::find($id);$model-&gt;status = 1;// 返回布尔值$model-&gt;save(); 删除12// 返回删除影响数$delete = TestModel::where(\"id\",1)-&gt;delete(); 事务事务的三个方法beginTransaction,commit,rollBack返回的都是NULL，出错必须用try catch结构包裹处理异常错误； 12345678&lt;?phptry &#123; DB::beginTransaction(); // todo something DB::commit();&#125; catch (Exception $e) &#123; DB::rollBack();&#125; 或者 1234567try &#123; TestModel::beginTransaction(); // todo something TestModel::commit();&#125; catch (Exception $e) &#123; TestModel::rollBack();&#125; 高级用法chuck处理大批量查询数据，减少内存占用 123TestModel::chunk(100,function($data)&#123; // todo something&#125;); 使用cursor()逻辑过滤 1234// 无论有无结果集均返回的是集合对象，可以使用toArray()s$result = TestModel::cursor()-&gt;filter(function ($test) &#123; return $test-&gt;id &gt; 500;&#125;); pluck返回指定字段的值数组 12345// 返回集合对象，无论是否有记录都返回集合对象，toArray()如果为空就是返回空数组。$result = TestModel::where(\"id\",\"&gt;=\",1)-&gt;pluck(\"id\");// 可以使用toArray()转换成数组$data = $resut=&gt;toArray();// [1,2,3,4,.....] 与get(&#39;id&#39;)返回结果的区别： 12$getResult = TestModel::get(\"id\")-&gt;toArray();$pluckResult = TestModel::pluck(\"id\")-&gt;toArray(); $getResult 结果: 1234567891011121314array ( 0 =&gt; array ( 'id' =&gt; 1, ), 1 =&gt; array ( 'id' =&gt; 2, ), 2 =&gt; array ( 'id' =&gt; 3, ),) $pluckResult 结果: 12345array ( 0 =&gt; 1, 1 =&gt; 2, 2 =&gt; 3,) pluck可以指定数据中的某个字段值作为键，假设数据库结构 Id status 1 Off 2 On 3 Freeze 1$pluckResult = TestModel::pluck(\"id\",\"status\")-&gt;toArray(); 则最终结果输出： 12345array ( \"off\" =&gt; 1, \"On\" =&gt; 2, \"Freeze\" =&gt; 3,) toSql查看构造器最终的SQL语句 12TestModel::toSql();TestModel::where(\"id\",\"&gt;=\",1)-&gt;toSql(); 总结大部分sql的关键字的表达方式，Eloquent都已经实现，IDE输入关键字可自动提示！对于复杂SQL比如使用了聚合函数等，Eloquent都提供了xxxRaw()的方法。比如：selectRaw，whereRaw灵活应用。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://diiyw.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://diiyw.com/tags/PHP/"},{"name":"Mysql","slug":"Mysql","permalink":"http://diiyw.com/tags/Mysql/"}]},{"title":"Socks4(a)\\5协议","slug":"socks-procotol","date":"2020-06-20T09:04:14.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2020/06/20/socks-procotol/","link":"","permalink":"http://diiyw.com/2020/06/20/socks-procotol/","excerpt":"传统的网络是一个C\\S架构，相当于直连接网络 有一天，网络服务提供商为了限制使用者访问某些互联网服务，于是设置了一堵墙，只有符合规则的网络传输才允许通过。目前全球最大，最厉害的是GFW，但是也做不到完全限制墙外访问，于是有人就找了台墙外主机，作为代理，所有墙内请求都需经过该主机经转发后访问具体目标，这样就可以在墙外轻松享受服务。","text":"传统的网络是一个C\\S架构，相当于直连接网络 有一天，网络服务提供商为了限制使用者访问某些互联网服务，于是设置了一堵墙，只有符合规则的网络传输才允许通过。目前全球最大，最厉害的是GFW，但是也做不到完全限制墙外访问，于是有人就找了台墙外主机，作为代理，所有墙内请求都需经过该主机经转发后访问具体目标，这样就可以在墙外轻松享受服务。 Socks协议至此衍生出来。 Socks是会话层的协议，位于表示层与传输层之间。目前有两个版本的协议。 Socks4(a)主要有以下几个RFC标准： http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocolhttp://www.rfc-editor.org/rfc/rfc1928.txthttp://www.smartftp.com/Products/SmartFTP/RFC/socks4a.protocol 流程 发送请求报文，报文结构如下所示，由五段组成，数字代表占用字节数 VER 版本号：固定是 0x04 CMD 说明此次需要执行什么操作 PORT 告诉代理我需要访问的墙外资源的端口 IP 告诉代理需要访问的墙外资源的IP USERID 一个标识ID，用于代理验证合法性的请求，可选项 NULL 结束符占用一个字节 服务端接收到请求，响应报文如下，其中PORT和IP可填充0，在某些客户端中不能去掉这两项参数，长度需要为8字节。响应之后服务端与IP:PORT建立连接，并直接绑定到客户端到服务端的连接中，后续服务端将不参与其中。 Socks4a的请求报文就不过多解释了，增加了域名解析的传参，是对Socks4的补充，如下所示： Socks5主要有以下几个RFC标准: https://tools.ietf.org/html/rfc1929 https://tools.ietf.org/html/rfc1961 https://tools.ietf.org/html/rfc3089 流程 socks5的请求报文只有三个参数 VER是版本号，固定0x05 NMETHODS 是表示METHODS的长度 METHODS验证方法，因为NMETHODS最大值只能是255所以参数最大字节数是255 服务端返回响应报文就很简单了 VER 是版本号固定 0x05 METHOD 服务端选择一个自己也支持的认证方案返回 校验通过，客服端继续发起第二次请求报文 VER 版本号，固定0x05 CMD 需要服务端做出的操作指令 RSV 是保留位，值是 0x00 ATYP 是目标地址类型 ADDR 就是目标地址 PORT 两个字节代表端口号 服务端接收到请求，返回响应报文，同时绑定连接 REP 响应状态码 RSV 保留位，值是 0x00 ATYP 是目标地址类型 ADDR 就是目标地址的值了，如果是IPv4，那么就是4 bytes，如果是IPv6那么就是16 bytes，如果是域名，那么第一个字节代表 接下来有多少个字节是表示目标地址 PORT 两个字节代表端口号 Socks5 支持UDP转发，应用场景更加广阔。 不过，现在的Socks4\\5代理协议已经不再建议在广域网使用了，GFW的强大超乎你的现象，SS和Socks已没有什么用武之地了。为了免疫GFW的特征提取，新的协议将会是新的加密性质进行传输，同时也更加符合现代网络的组织结构，socks只是本地一个转换配角。Vmess才是目前受到广泛使用协议。 [附] Go语言的一个简单socks4/5实现 https://github.com/diiyw/mep","categories":[{"name":"Network","slug":"Network","permalink":"http://diiyw.com/categories/Network/"}],"tags":[{"name":"socks4(a)","slug":"socks4-a","permalink":"http://diiyw.com/tags/socks4-a/"},{"name":"socks5","slug":"socks5","permalink":"http://diiyw.com/tags/socks5/"}]},{"title":"Redis的消息系统","slug":"redis-message-system","date":"2020-04-10T03:39:33.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2020/04/10/redis-message-system/","link":"","permalink":"http://diiyw.com/2020/04/10/redis-message-system/","excerpt":"","text":"消息系统所谓消息系统就是消息在发布者（Publishers）和订阅者（Subscribers）之间的传递规则，发布者不关心消息到底需要被谁接收使用，订阅者也不需要关心消息来自哪个发布者。发布者和订阅者之间通过频道（channels）来进行消息传递，发布者可以发布消息到多个频道中，而订阅者只会订阅感兴趣的频道。这样的解耦可以使得我们的网络拓扑结构更具扩展性。 Redis中提供了以下的命令，可实现消息系统 PSUBSCRIBE PUBLISH PUBSUB PUNSUBSCRIBE SUBSCRIBE UNSUBSCRIBE 举个例子： 连接A 1234127.0.0.1:6379&gt; SUBSCRIBE speaker1) \"subscribe\"2) \"speaker\"3) (integer) 1 订阅了一个speaker的channel，我们在另外一个端口中发布消息看看： 连接B 12127.0.0.1:6379&gt; PUBLISH speaker \"hello world!\"(integer) 1 连接A立即收到消息 1231) \"message\"2) \"speaker\"3) \"hello world!\" 推送消息的格式化Redis中的一条消息是一个数组类型。 订阅时 1SUBSCRIBE speaker 实际发送了指令 1*3\\r\\n$9\\r\\nsubscribe\\r\\n$7\\r\\nspeaker\\r\\n:1 *3数组的长度为3，$9,$7表示接下来的数组元素的长度,:1表示此次订阅了1个channel。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://diiyw.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://diiyw.com/tags/Redis/"},{"name":"Message System","slug":"Message-System","permalink":"http://diiyw.com/tags/Message-System/"}]},{"title":"使用管道加速redis的查询","slug":"using-piplining-to-speedup-redis-queries","date":"2020-03-28T05:16:52.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2020/03/28/using-piplining-to-speedup-redis-queries/","link":"","permalink":"http://diiyw.com/2020/03/28/using-piplining-to-speedup-redis-queries/","excerpt":"请求/响应模型和RTTRedis的TCP的服务采用Client/Server模型。意味着一次查询将遵循以下步骤： 客户端发起请求阻塞直到服务器响应。 服务器会处理请求操作的命令，并返回结果。 例如下面的四次的命令执行 12345678127.0.0.1:6379&gt; incr x(integer) 1127.0.0.1:6379&gt; incr x(integer) 2127.0.0.1:6379&gt; incr x(integer) 3127.0.0.1:6379&gt; incr x(integer) 4 客户端和服务端的通讯是建立在网络之上，如果是回环链路（本地网络）将是非常快的，相反互联网之上将相对较慢。但是无论在哪种网络下，数据包从客服端到服务端，再由服务端返回到客户端并接收的一个周期我们叫做RTT(Round Trip Time)，这样我们可以参考RTT时间来优化性能（比如插入大量的元素，或者添加大量的数据库键值）在回环链路的RTT是非常短的(ping 127.0.0.1 可以看到结果)，但是我们写入大量数据时，性能依旧是个问题。","text":"请求/响应模型和RTTRedis的TCP的服务采用Client/Server模型。意味着一次查询将遵循以下步骤： 客户端发起请求阻塞直到服务器响应。 服务器会处理请求操作的命令，并返回结果。 例如下面的四次的命令执行 12345678127.0.0.1:6379&gt; incr x(integer) 1127.0.0.1:6379&gt; incr x(integer) 2127.0.0.1:6379&gt; incr x(integer) 3127.0.0.1:6379&gt; incr x(integer) 4 客户端和服务端的通讯是建立在网络之上，如果是回环链路（本地网络）将是非常快的，相反互联网之上将相对较慢。但是无论在哪种网络下，数据包从客服端到服务端，再由服务端返回到客户端并接收的一个周期我们叫做RTT(Round Trip Time)，这样我们可以参考RTT时间来优化性能（比如插入大量的元素，或者添加大量的数据库键值）在回环链路的RTT是非常短的(ping 127.0.0.1 可以看到结果)，但是我们写入大量数据时，性能依旧是个问题。 Redis 管道Redis 管道的就是将多次需要执行的指令合并成一次传输，服务端会一次返回每个指令的结果。如: 1234$ (printf \"PING\\r\\nPING\\r\\nPING\\r\\n\"; sleep 1) | nc localhost 6379+PONG+PONG+PONG 回到上面的例子，使用管道进行发送 1234$ (printf \"incr x\\r\\nincr x\\r\\nincr x\\r\\n\"; sleep 1) | redis-cli --pipeAll data transferred. Waiting for the last reply...Last reply received from server.errors: 0, replies: 3 特别注意： 如果客户端通过管道发送大量的命令，服务端将会使用内存队列缓存每个命令结果。所以在发送时需要控制命令的数量。 不只是RTT的问题使用管道是可以上少网络请求，从而减少RTT耗时。实际上除了网络层上面的时间消耗，使用非管道进行操作时，redis需要频繁的进行Socket I/O的read()和write() 频繁的上下文切换，是一笔巨大的开销。如果使用了管道，只需要一次的read(),，同理write()也只需一次系统调用，极大的减少了开销。这样每秒执行的总查询数，从最初几乎呈线性增加，最终达到不使用管道方法基准的10倍， 但是实际测试中却达到了惊人的400倍？基于Go语言的测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Redis server版本为5.0.4 On Mac OS Xpackage mainimport ( \"fmt\" \"net\" \"strings\" \"time\")func main() &#123; start := time.Now() pipelining() fmt.Printf(\"with pipelining: %s\\n\", time.Now().Sub(start)) start = time.Now() withoutPipelining() fmt.Printf(\"without pipelining: %s\\n\", time.Now().Sub(start))&#125;func withoutPipelining() &#123; conn, err := net.Dial(\"tcp4\", \"127.0.0.1:6379\") if err != nil &#123; return &#125; defer conn.Close() for i := 0; i &lt; 10000; i++ &#123; _, _ = conn.Write([]byte(\"PING\\r\\n\")) var b = make([]byte, 7) _, _ = conn.Read(b) &#125;&#125;func pipelining() &#123; conn, err := net.Dial(\"tcp4\", \"127.0.0.1:6379\") if err != nil &#123; return &#125; defer conn.Close() var pings strings.Builder for i := 0; i &lt; 10000; i++ &#123; pings.WriteString(\"PING\\r\\n\") &#125; _, _ = conn.Write([]byte(pings.String())) var b = make([]byte, 7000) _, _ = conn.Read(b)&#125; 12with pipelining: 20.74797mswithout pipelining: 8.502332207s 管道和脚本对比Redis在2.6之后的版本中支持脚本。管道的一些例子可以直接转换到脚本方式更高的效率执行。特别是需要在服务端进行大量计算时，脚本可以最小延迟的执行，使得读取，计算，写入等操作变的非常快。 扩展：为什么在本地回环链路上循环执行操作还是很慢？1234# 伪代码FOR-ONE-SECOND: Redis.SET(\"foo\",\"bar\")END 这段代码不停的进行SET操作，本地回环链路中，都是在同一台机子测试时，只有内存的数据拷贝，实际上应该是不会有额外的损耗的？但是却却相反，依然很慢。这是为什么呢？真实原因是系统不是一直都运行某个程序的,任何程序都是在系统的内核调度下运行，所以频繁SET系统要进行频繁的调度才能最终完成任务，本质上还是操作太多的IO操作，才导致性能下降。这就是为什么本地环境下测试依然很慢的原因。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://diiyw.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://diiyw.com/tags/Redis/"}]},{"title":"x509 certificate is valid","slug":"x509-certificate-is-valid","date":"2020-02-24T06:19:30.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2020/02/24/x509-certificate-is-valid/","link":"","permalink":"http://diiyw.com/2020/02/24/x509-certificate-is-valid/","excerpt":"","text":"问题描述Go在拉取包的报了这一个错误： x509: certificate is valid for gomirrors.org, www.gomirrors.org, not goproxy.io goproxy.io是Go的模块代理服务。 解决办法出现这种情况基本是受到了中间人攻击，所谓中间人攻击就是你的电脑网络请求被监控。 一般出现在公司电脑上，或者你开启了网络请求的拦截，比如抓包工具Charles。我们把它关闭就正常了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://diiyw.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://diiyw.com/tags/Linux/"},{"name":"SSL","slug":"SSL","permalink":"http://diiyw.com/tags/SSL/"}]},{"title":"Mysql的事务隔离级别","slug":"mysql-transaction-isolation","date":"2019-10-31T01:43:39.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/10/31/mysql-transaction-isolation/","link":"","permalink":"http://diiyw.com/2019/10/31/mysql-transaction-isolation/","excerpt":"Mysql 有四种事务隔离级别 隔离级别 脏读（Dirty Read） 不可重复读（NonRepeatable Read） 幻读（Phantom Read） 读未提交（Read uncommitted） 可能 可能 可能 读已提交（Read committed 不可能 可能 可能 可重复读（Repeatable read） 不可能 不可能 可能 可串行化（Serializable ） 不可能 不可能 不可能 脏读 一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，读取到了不想得到的数据了。 幻读 第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 不可重复读 数据库访问中，在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。","text":"Mysql 有四种事务隔离级别 隔离级别 脏读（Dirty Read） 不可重复读（NonRepeatable Read） 幻读（Phantom Read） 读未提交（Read uncommitted） 可能 可能 可能 读已提交（Read committed 不可能 可能 可能 可重复读（Repeatable read） 不可能 不可能 可能 可串行化（Serializable ） 不可能 不可能 不可能 脏读 一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，读取到了不想得到的数据了。 幻读 第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 不可重复读 数据库访问中，在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 InnoDB默认是可重复读的（REPEATABLE READ），查询当前使用的隔离级别 1234567mysql&gt; SELECT @@tx_isolation;+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.01 sec) test数据库测试新建一张表person测试 1234567CREATE TABLE `person` ( `id` mediumint(8) unsigned NOT NULL AUTO_INCREMENT, `city` varchar(255) DEFAULT NULL, `age` mediumint(9) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 脏读我们开启两个客服端A、B备用 A 开启事务插入一条数据，不需要提交事务 12345678910111213mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into person (city)values(&apos;china&apos;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 1 | china | NULL | NULL |+----+-------+------+------+1 row in set (0.00 sec) B 中并不会查询到A中事务提交的数据，不会出现脏读。 12mysql&gt; select * from person;Empty set (0.00 sec) B客户端更改为读未提交（Read Uncommitted）那么就能读取到A事务中插入的数据。 12345678910mysql&gt; set session transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 1 | china | NULL | NULL |+----+-------+------+------+1 row in set (0.00 sec) 查询A中隔离级别 1234567mysql&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| REPEATABLE-READ |+------------------------+1 row in set (0.00 sec) 虽然A中的隔离级别是Repeatable read但是B指定Read Uncommitted级别照样读取到了其中的事务数据。 到此A的隔离级别为Repeatable read,修改B的隔离级别为Read committed 12mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec) 不可重复度之前的例子中手动回滚了事务，此时person表是空的。我们A和B都开启一个事务，A中提交事务，观察B查询数据。 B 开启事务查询数据 12345mysql&gt; begin;Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from person;Empty set (0.00 sec) A开启事务插入一条记录 12345678mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into person (city)values(&apos;china&apos;);Query OK, 1 row affected (0.01 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec) B事务中查询记录 1234567mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 2 | china | NULL | NULL |+----+-------+------+------+1 row in set (0.01 sec) B事务中两次查询到数据不一致。不可重复读就是事务中数据不能进行重复读取，不然会导致数据不一致。 可重复读同上面操作我们修改B的隔离级别为Repeatable read 1set session transaction isolation level repeatable read 此时A和B的隔离级别是一致的，重复上面的操作 B 开启事务查询数据 1234567mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 2 | china | NULL | NULL |+----+-------+------+------+1 row in set (0.00 sec) A开启事务插入一条记录 12345678mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into person (city)values(&apos;china&apos;);Query OK, 1 row affected (0.01 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec) B事务中查询记录 1234567mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 2 | china | NULL | NULL |+----+-------+------+------+1 row in set (0.00 sec) B事务中两次查询到数据是一致的。 幻读A 和B事务中进行操作，步骤接替进行看效果 A 12mysql&gt; begin;Query OK, 0 rows affected (0.00 sec) B 12mysql&gt; begin;Query OK, 0 rows affected (0.00 sec) A 12345678mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 2 | china | NULL | NULL || 3 | china | NULL | NULL |+----+-------+------+------+2 rows in set (0.01 sec) B 12345678mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 2 | china | NULL | NULL || 3 | china | NULL | NULL |+----+-------+------+------+2 rows in set (0.00 sec) A 12mysql&gt; insert into person (id,city)values(1,&apos;xm&apos;);Query OK, 1 row affected (0.00 sec) B 12345678mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 2 | china | NULL | NULL || 3 | china | NULL | NULL |+----+-------+------+------+2 rows in set (0.00 sec) A 12mysql&gt; commit;Query OK, 0 rows affected (0.00 sec) B 12345678mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 2 | china | NULL | NULL || 3 | china | NULL | NULL |+----+-------+------+------+2 rows in set (0.00 sec) A 123456789mysql&gt; select * from person;+----+-------+------+------+| id | city | age | name |+----+-------+------+------+| 1 | xm | NULL | NULL || 2 | china | NULL | NULL || 3 | china | NULL | NULL |+----+-------+------+------+3 rows in set (0.00 sec) B 12mysql&gt; insert into person(id,city)values(1,&quot;xm2&quot;);ERROR 1062 (23000): Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos; 仔细对比可以发现，即使A中提交了新数据，但是B中并不会找到新增加的数据，所以天真的以为可以添加一条新数据，这时候mysql报出来主键重复了，就像是产生幻觉一样。 在B查询语句可以知道数据库只有两条记录，如果我们在B中更新记录 123mysql&gt; update person set city=&apos;b&apos;;Query OK, 3 rows affected (0.01 sec)Rows matched: 3 Changed: 3 Warnings: 0 咦！怎么有三条记录更新，不是两条吗。这同样产生了幻觉。 *注意 *当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。 当然如果使用update语句，mysql会加锁会保证数据一致。 A 123456mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; update person set city=&apos;a&apos; where id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 B等待A释放锁或者超时 12345mysql&gt; begin;Query OK, 0 rows affected (0.01 sec)mysql&gt; update person set city=&apos;b&apos; where id=1;ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://diiyw.com/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://diiyw.com/tags/Mysql/"}]},{"title":"Go中的堆栈与逃逸分析","slug":"go-stack-heap-and-escape","date":"2019-10-28T07:25:33.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/10/28/go-stack-heap-and-escape/","link":"","permalink":"http://diiyw.com/2019/10/28/go-stack-heap-and-escape/","excerpt":"Go的变量到底是分配在堆还是栈，我们先聊下下概念。 堆(heap) 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 栈 (stack) 由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。Go在分配栈的时候，预先分配2k的空间。 理论上分配在栈上的数据操作速度快与堆上。堆上使用的内存需要垃圾回收(GC),栈上的内存是自动释放的且是明确不共享的。","text":"Go的变量到底是分配在堆还是栈，我们先聊下下概念。 堆(heap) 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 栈 (stack) 由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。Go在分配栈的时候，预先分配2k的空间。 理论上分配在栈上的数据操作速度快与堆上。堆上使用的内存需要垃圾回收(GC),栈上的内存是自动释放的且是明确不共享的。 先看个例子 escape.go : 1234567891011121314151617181920package maintype user struct &#123; name string email string&#125;func main() &#123; newUser()&#125;//go:noinlinefunc newUser() user &#123; u := user&#123; name: \"tom\", email: \"tom@x.com\", &#125; return u&#125; 编译分析 12~ go tool compile -m escape.goescape.go:8:6: can inline main 这里只说明main可以内联，此时u是分配到栈上的，因为没有其他程序共享u变量。继续修改下 1234567891011121314151617181920package maintype user struct &#123; name string email string&#125;func main() &#123; newUser()&#125;//go:noinlinefunc newUser() *user &#123; u := user&#123; name: \"tom\", email: \"tom@x.com\", &#125; return &amp;u&#125; 结果 1234~ go tool compile -m escape.goescape.go:8:6: can inline mainescape.go:18:6: can inline changeNameescape.go:18:17: moved to heap: u 我们返回user的指针，Go判断这段内存需要被共享于是本身u在堆上的被移动到了栈了。如果我们修改 1234567func newUser() *user &#123; u := &amp;user&#123; name: \"tom\", email: \"tom@x.com\", &#125; return u&#125; 123~ go tool compile -m escape.goescape.go:8:6: can inline mainescape.go:17:10: &amp;user literal escapes to heap Go直接将这段内存分配到堆上了。一旦分配在堆上就要进行垃圾回收处理了。这里要注意的每个Goroutine都有自己的栈内存互不影响，Goroutine之间栈内存能不能共享！","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://diiyw.com/categories/Go语言/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://diiyw.com/tags/Golang/"}]},{"title":"Go语言Channel的Buffered与Unbuffered","slug":"go-channel-buffer","date":"2019-10-24T02:50:39.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/10/24/go-channel-buffer/","link":"","permalink":"http://diiyw.com/2019/10/24/go-channel-buffer/","excerpt":"Go语言channel在应用中相当的常见了，其中channel分两类，一种是 buffered channel，另一种是 unbuffered channel。","text":"Go语言channel在应用中相当的常见了，其中channel分两类，一种是 buffered channel，另一种是 unbuffered channel。 Unbuffered Channel没缓冲的channel，我们看个例子 12345678910111213package mainimport ( \"fmt\" \"time\")func main() &#123; go func() &#123; fmt.Println(\"Goroutine.\") &#125;() time.Sleep(1 * time.Second)&#125; 如果我们不休眠一秒是看不到输出的。这里我们设置的Timeout是1秒，我们默认了这个Goroutine不会执行耗时任务，假如执行时间未知，此方法就行不通。可以引入channel解决这个问题，请看示例 12345678910111213141516package mainimport ( \"fmt\" \"time\")func main() &#123; end := make(chan bool) go func() &#123; time.Sleep(time.Second * 2) fmt.Println(\"Goroutine.\") end &lt;- true &#125;() &lt;-end&#125; end是一个Unbuffered channel，无论Goroutine执行多久结束，主线程都会等待其完全执行完成，从这里看出来 Unbuffered channel是可以用来做同步的，相反的Buffered channel可以做异步。上面的例子可以做一些变化，如 12345678910111213141516package mainimport ( \"fmt\" \"time\")func main() &#123; end := make(chan bool) go func() &#123; time.Sleep(time.Second * 2) fmt.Println(\"Goroutine.\") &lt;-end &#125;() end &lt;- true&#125; 这两种结果是一样的。只是方式上存在差异，前者读阻塞，后者写阻塞。 Buffered Channel上面的例子改成带缓冲的 12345678910111213141516package mainimport ( \"fmt\" \"time\")func main() &#123; end := make(chan bool, 1) go func() &#123; time.Sleep(time.Second * 2) fmt.Println(\"Goroutine.\") &lt;-end &#125;() end &lt;- true&#125; 程序不会有任何输出，此时的end是带缓冲的，没等Goroutine执行，end就写入true主程就退出了。但是我们换一种方式 12345678910111213141516package mainimport ( \"fmt\" \"time\")func main() &#123; end := make(chan bool, 1) go func() &#123; time.Sleep(time.Second * 2) fmt.Println(\"Goroutine.\") end &lt;- true &#125;() &lt;-end&#125; 此时是可以输出的。虽然我们设置缓冲，但是&lt;-end是读阻塞的，因为此时end并没有值。所以Buffered Channel也是可以做同步的，只是应用在多个Goroutine。但是不建议这样做，如果不小心对channel操作就会造成意想不到的一些BUG，此时应该考虑使用context包进行上下文管理。","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://diiyw.com/categories/Go语言/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://diiyw.com/tags/Golang/"}]},{"title":"Go Module使用教程","slug":"go-moudle-using","date":"2019-10-15T03:19:33.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/10/15/go-moudle-using/","link":"","permalink":"http://diiyw.com/2019/10/15/go-moudle-using/","excerpt":"Go从1.11版本开始内置包管理工具，直到1.14已经正式支持Go Mdoule。以最新版Go1.13为例，学习GO包管。","text":"Go从1.11版本开始内置包管理工具，直到1.14已经正式支持Go Mdoule。以最新版Go1.13为例，学习GO包管。 启用配置环境变量GO111MODULE，默认是auto，如果目录中包含go.mod将使用go modules模式 1export GO111MODULE=on 使用显示命令行帮助 1go mod 进入到项目目录初始化模块 1go mod init &#123;moudle-name&#125; 这里需要注意，你的包名需要与被引入使用的包名一致否则无法匹配，Go将无法编译应用。例如：你将包放到了github.com/xx/package 如果这里指定了{moudle-name}为package，那么别人引用此包，将报错无法继续。 1go mod tidy 执行该条命令就开始自动下载安装第三方包了，同时如果有包不在使用，将会从go.mod中移除。执行go build 也会自动安装依赖，是不是很方便。 go.mod文件说明示例 123456789module github.com/micro/go-microgo 1.13require ( github.com/BurntSushi/toml v0.3.1 github.com/beevik/ntp v0.2.0 github.com/bitly/go-simplejson v0.5.0) 很直观的就可以看的出来require就是引用的包格式是 “包名+版本”这的版本其实就是tag，如果没有tag就会拉取master分支，会是下面的形式 1golang.org/x/net v0.0.0-20191014212845-da9a3fd4c582 20191014212845是commit的提交时间，da9a3fd4c582就是此次的commit的哈希。使用go get时我们可以指定版本或者分支如 12go get gitlab.com/xxx/xx@cheuk-gogo get gitlab.com/xxx/xx@v1.0.2 如果是手动写入go.mod需要将@替换成空格，这样就可以正常拉取。 包映射除了require方式，我们还可以指定require的包使用本地指定的包 1replace github.com/BurntSushi/toml v0.3.1 =&gt; ./toml 包github.com/BurntSushi/toml现在引用了一个我们放在本地的一个目录toml 代理现在Go第三方有提供了代理，目前有三个 https://goproxy.cn https://goproxy.io https://mirrors.aliyun.com/goproxy/ 设置环境变量GOPROXY，direct表示在出错的时候使用直连。 1export GOPROXY=https://goproxy.cn,direct 私有包我们开发不可能所有包来自github，大部分公司都自建了gitlab服务。需要进行以下两部操作 1git config --global url.\"git@gitlab.xxx.com:\".insteadOf \"http://gitlab.xxx.com/\" 这里将http替换成ssh可以进行免密拉取包。如果我们设置了代理，我们配置GOPRIVATE让其不走代理 1export GOPRIVATE=*.xxx.com","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://diiyw.com/categories/Go语言/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://diiyw.com/tags/Go/"}]},{"title":"PHP的XDebug调试工具安装","slug":"php-xdebug-install","date":"2019-10-10T09:37:58.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/10/10/php-xdebug-install/","link":"","permalink":"http://diiyw.com/2019/10/10/php-xdebug-install/","excerpt":"XDebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况，极其方便。","text":"XDebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况，极其方便。 安装最简单的安装方式 1pecl install xdebug 这种方式安装后，php.ini自动添加启用扩展。 可用通过 1php -m |grep xdebug 查询是否安装好可扩展。 详情可以参考官方文档。 配置打开php.ini编辑，如果不知道php.ini在自己电脑哪个位置的，可以执行 12345➜ php --iniConfiguration File (php.ini) Path: /usr/local/etc/php/7.3Loaded Configuration File: /usr/local/etc/php/7.3/php.iniScan for additional .ini files in: /usr/local/etc/php/7.3/conf.dAdditional .ini files parsed: /usr/local/etc/php/7.3/conf.d/ext-opcache.ini 可以看到php.ini的文件全路径了。 将下面的配置，添加到php.ini最后 123456789101112131415161718;开启远程调试[XDebug]xdebug.remote_enable = 1xdebug.profiler_enable = 1xdebug.remote_host=0.0.0.0xdebug.profiler_enable_trigger = 1xdebug.profiler_output_name = cachegrind.out.%t.%pxdebug.profiler_output_dir = \"~/phpxdebug\"xdebug.remote_autostart=1xdebug.auto_trace=1xdebug.show_local_vars=0;远程处理协议xdebug.remote_handel=dbgp;端口号xdebug.remote_port=9001;IDE KEYxdebug.idekey=\"phpxdebug\" 如果配置了php服务则重启下php服务。 IDE配置以idea为例，修改下图的配置,端口需改为我们配置的9001 记得点击，开始监听调试，图示表示已经在监听。 创建文件验证一下 123456789&lt;?php$q = new \\stdClass();$q-&gt;name = 1;$b = [\"age\" =&gt; 13];var_dump((object)array_merge((array)$q, $b)); 在第7行打一个断点。 1php index.php 如果IDE弹出Debug窗口，那么xdebug我们已经配置成功，尽情玩耍吧。如图所示","categories":[{"name":"PHP","slug":"PHP","permalink":"http://diiyw.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://diiyw.com/tags/PHP/"},{"name":"XDebug","slug":"XDebug","permalink":"http://diiyw.com/tags/XDebug/"}]},{"title":"在Docker中调试Go程序","slug":"go-docker-debug","date":"2019-09-29T09:48:36.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/09/29/go-docker-debug/","link":"","permalink":"http://diiyw.com/2019/09/29/go-docker-debug/","excerpt":"我们已经构建一个用于编译Go程序的，如果我们使用Mac和Windows开发go，又该如在docker中调试我们程序。这其中用到了一个调试工具delve的远程调试功能。","text":"我们已经构建一个用于编译Go程序的，如果我们使用Mac和Windows开发go，又该如在docker中调试我们程序。这其中用到了一个调试工具delve的远程调试功能。 认识Delve项目地址：https://github.com/go-delve/delve Devle是一个非常棒的golang 调试工具，支持多种调试方式，直接运行调试，或者attach到一个正在运行中的Go程序，进行调试。线上Go服务出现问题时，Devle是必不可少的在线调试工具，如果使用docker，也可以把Devle打进docker镜像里，从而调试代码。 创建调试容器Dockerfile内容如下 1234567891011121314151617# 最新版本构建容器FROM golang:latestMAINTAINER cheuk# 创建构建目录RUN mkdir /godebuger# 工作目录WORKDIR /godebuger# delve的调试端口EXPOSE 2345# 环境变量配置ENV GOPATH $GOPATH:/godebugerENV GO111MODULE on# 开下梯子ENV GOPROXY \"https://goproxy.cn\"RUN go get -u github.com/go-delve/delve/cmd/dlv# 磁盘映射packageVOLUME [\"/godebuger\",\"/go/src\"] 构建容器 1docker build -t godebuger . 选择一个项目，并映射到进入容器中，$(pwd)就是项目的目录，我习惯进入项目目录执行。 1docker run --rm -it -v $GOPATH/src:/go/src -v $(pwd):$(pwd) godebuger 注意：这里$(pwd):$(pwd)是将项目完整目录映射到容器，不然在IDE下无法进行打断点调试。 如果我们还使用GOPATH模式编译程序那么 1export GO111MODULE=off 进入到项目目录编译，开始调试程序 1go build -gcflags \"all=-N -l\" 1dlv --listen=:2345 --headless=true --api-version=2 --accept-multiclient exec ./godebuger 这里的godebuger是项目编译后的程序名称。 这里每一步操作都很麻烦，我们写个脚本放到$GOPATH/bin。如果已经使用go mod 模式则需要去掉-e GO111MODULE=off 1234567#!/bin/bashdocker run --rm -it \\-v $GOPATH/src:/go/src \\-v $(pwd):$(pwd) \\-e GO111MODULE=off \\-p 2345:2345 \\godebuger /bin/sh -c 'cd '\"$(pwd)\"' &amp;&amp; go build -gcflags \"all=-N -l\" -o godebuger &amp;&amp; dlv --listen=:2345 --headless=true --api-version=2 --accept-multiclient exec ./godebuger' 在项目目录执行 12~ godebugerAPI server listening at: [::]:2345 即可开启调试。如果是*nix系统，添加下执行权限。 1chmod +x $GOPATH/bin/godebuger IDE配置使用idea为例，点击编辑配置项 添加go远程调试项，修改名称点OK创建 点击如图所示的按钮，即可正常调试Go程序","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://diiyw.com/categories/Go语言/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://diiyw.com/tags/Golang/"},{"name":"Docker","slug":"Docker","permalink":"http://diiyw.com/tags/Docker/"}]},{"title":"Go1.5至Go1.14的版本更新史","slug":"go-version-diff","date":"2019-09-29T02:35:25.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/09/29/go-version-diff/","link":"","permalink":"http://diiyw.com/2019/09/29/go-version-diff/","excerpt":"我们现在使用的是Go 1.7.6版本。至于为什么从1.5开始总结，这是一个很重要的版本，实现方面有很多变化。最重要的是实现了自举。本文列出一些重大变化以及对我们升级有用的信息。","text":"我们现在使用的是Go 1.7.6版本。至于为什么从1.5开始总结，这是一个很重要的版本，实现方面有很多变化。最重要的是实现了自举。本文列出一些重大变化以及对我们升级有用的信息。 Go 1.5该版本主要变化有以下几点 实现自举，使用少量汇编，用GO写GO。实现自举的目的是为了能更好的对GC管理优化 引入并发垃圾回收器，大幅降低GC延迟（Stop The World） 默认情况下，Go 程序运行时的 GOMAXPROCS 会被设置为可用的核数，之前默认为 1。再也不用手动去设置了 Map literalsGo1.4之前我们需要这样写代码： 123456789101112131415161718package mainimport ( \"fmt\")type i32 struct &#123; value int&#125;func main() &#123; var i = []i32&#123;&#123;1&#125;, &#123;2&#125;&#125; var m = map[i32]string&#123; i32&#123;3&#125;:\"i32=3\", i32&#123;4&#125;:\"i32=4\", &#125; fmt.Println(i,m)&#125; 可以看到，对于i32类型来说，在初始化一个切片时，无需显式的带上元素类型名称i32，即 1var i = []i32&#123;&#123;1&#125;, &#123;2&#125;&#125; 而不是需要传入名称： 1var i = []i32&#123;i32&#123;1&#125;, i32&#123;2&#125;&#125; 但是当i32作为map类型的key时，初始化map时则需要带上元素类型i32。在Go 1.5版本修复了。也就是说，下面的代码在Go 1.5以及之后版本中可以顺利编译通过 12345678func main() &#123; var i = []i32&#123;&#123;1&#125;, &#123;2&#125;&#125; var m = map[i32]string&#123; &#123;3&#125;:\"i32=3\", &#123;4&#125;:\"i32=4\", &#125; fmt.Println(i,m)&#125; GO 1.6该版本主要对GO的生态进行了调整 添加linux/mips64，linux/mips64le，android/386平台的实验性支持。 go tool工具链调整，对位于我们升级意义不大。 运行时和大面积的标准库BUG修复和调整。 运行时现在如果我们并发的map进行操作，GO会检测并抛出错误。Go 1.6之前版本，一旦程序以panic方式退出，runtime便会将所有goroutine的stack信息打印出来，现在只会打印正在running的goroutine的stack信息。 核心库和标准包HTTP/2Go 1.6已经标准库中已经支持HTTP/2。并且当使用https时，client和server端将自动默认使用HTTP/2协议。 TemplatesGo templates的空白字符包括：空格、水平tab、回车和换行符。Go 1.6提供了来帮助大家去除action前后的空白字符。示例 1234567891011121314151617181920package mainimport ( \"log\" \"os\" \"text/template\")func main() &#123; var t = template.Must(template.New(\"tmpl\").Parse(` &#123;&#123;\"hello\" -&#125;&#125; &lt;br&gt; &#123;&#123;- \"world\"&#125;&#125; `)) err := t.Execute(os.Stdout, nil) if err != nil &#123; log.Println(\"executing template:\", err) &#125;&#125; 输出hello&lt;br&gt;world，&lt;br&gt;左右的空白将会被清除。 Tlscrypto/tls 包现在如果没有指定证书也可以监听。 123456789101112131415161718package mainimport ( \"crypto/tls\" \"fmt\")func main() &#123; var config = &amp;tls.Config&#123; GetCertificate: func(info *tls.ClientHelloInfo) (certificate *tls.Certificate, e error) &#123; return nil, nil &#125;, &#125; _, err := tls.Listen(\"tcp4\", \":2020\", config) if err != nil &#123; fmt.Println(err) &#125;&#125; Go 1.7该版本的主要是对性能的影响 实验性的支持linux/s390x，plan9/arm 编译性能提升，编译出的文件变小 运行时和标准库BUG修复和调整 HTTP Tracing引用net/http/httptrace包对http请求进行追踪测试 测试包testing现在支持子测试（subtest），更好的支持表驱动测试和更细的粒度测试。 表格驱动测试：有时也被归为关键字驱动测试(keyword-driven testing，是针对自动化测试的软件测试方法，它将创建测试程序的步骤分为规划及实现二个阶段。 1234567891011121314package mainimport \"testing\"func TestEq(t *testing.T) &#123; var s1 = []int&#123;1, 2, 3&#125; var s2 = []int&#123;1, 4, 3&#125; for k1, v1 := range s1 &#123; v2 := s2[k1] if v1 != v2 &#123; t.Errorf(\"s1:%d != s2:%d\", v1, v2) &#125; &#125;&#125; 平常我们是使用此方法测试，s1是我们期望的结果，我们改造一下使用subtest 123456789101112131415161718192021222324252627282930// sub_test.gopackage mainimport \"testing\"func TestEq(t *testing.T) &#123; var s1 = []int&#123;1, 2, 3&#125; var s2 = []int&#123;1, 4, 3&#125; for k1, v1 := range s1 &#123; v2 := s2[k1] t.Run(\"index 0\", func(t *testing.T) &#123; if k1 != 0 &#123; t.Skip(k1) &#125; assertEq(v1, v2, t) &#125;) t.Run(\"index 1\", func(t *testing.T) &#123; if k1 != 1 &#123; t.Skip(k1) &#125; assertEq(v1, v2, t) &#125;) &#125;&#125;func assertEq(v1, v2 int, t *testing.T) &#123; if v1 != v2 &#123; t.Errorf(\"got %d; want %d\", v2, v1) &#125;&#125; 123=== RUN TestEq/index_1#01 --- FAIL: TestEq/index_1#01 (0.00s) sub_test.go:27: got 4; want 2 测试结果中index_1是我们子测试的名称，这样我们可很清楚的知道那部分测试是有问题的。 核心标准库ContextGo 1.7 已经将context上下文包引入到标准库中，可以直接import，轻松进行并发控制，平滑退出 1234567891011121314151617181920212223242526package mainimport ( \"context\" \"fmt\" \"time\")func main() &#123; ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() go func(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(\"监控超时退出:\", ctx.Err()) return default: fmt.Println(\"正在监控Goroutine\") time.Sleep(1 * time.Second) &#125; &#125; &#125;(ctx) time.Sleep(5 * time.Second)&#125; 1234正在监控Goroutine正在监控Goroutine正在监控Goroutine监控超时退出: context deadline exceeded Stringsstrings的Reader 的 Read方法如果没有数据将会返回长度0和io.EOF 之前的版本不会产生错误！ Timetime.Duration 如果0时段，现在time.Duration.String是0s而不是0 12345678910package mainimport ( \"fmt\" \"time\")func main() &#123; fmt.Println(time.Duration(0))&#125; Go 1.8此版本调整的地方 GC延迟大幅降低，通常是100ms，大部分情况下都是10ms左右 正式支持linux/mips64，linux/mips64le 移除go tool yacc 编译性能提升15% 默认安装Go之后 $GOPATH 默认路径为 $HOME/go，如果是Windows则是%USERPROFILE%/go Plugin的初步支持 语言1.8 开始，tag不一样的struct可以执行显性转化。 123456789101112131415161718package mainimport \"fmt\"type A struct &#123; Value int `json:\"value\"`&#125;type B struct &#123; Value int `json:\"b_value\"`&#125;func main() &#123; var a = &amp;A&#123;1&#125; var b = (*B)(a) fmt.Println(b)&#125; 核心和标准库Sort1.8 之前版本，我们对自定义的slice排序需要实现sort.Inteface接口 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"sort\")type Student struct &#123; Score int&#125;// 实现sort.Inteface接口type Person []Studentfunc (p Person) Len() int &#123; return len(p) &#125;func (p Person) Less(i, j int) bool &#123; return p[i].Score &lt; p[j].Score &#125;func (p Person) Swap(i, j int) &#123; p[i], p[j] = p[j], p[i] &#125;var students = Person&#123;&#123;90&#125;,&#123;83&#125;,&#123;87&#125;&#125;func main() &#123; sort.Sort(students) fmt.Println(students)&#125; 1.8 之后，我们可以使用更快的方式 123456789101112131415161718192021package mainimport ( \"fmt\" \"sort\")type Student struct &#123; Score int&#125;type Person []Studentvar students = Person&#123;&#123;90&#125;, &#123;83&#125;, &#123;87&#125;&#125;func main() &#123; sort.Slice(students, func(i, j int) bool &#123; return students[i].Score &lt; students[j].Score &#125;) fmt.Println(students)&#125; 两种结果是一样的，省掉额外代码实现sort.Inteface接口 HTTP/2 PushGo 1.8新增了对HTTP/2 Push的支持。 简单的介绍下HTTP/2 Push：从图中当Browser向Server发起Get page.html请求后，在同一条TCP Connection上，Server主动将style.css和image.png两个资源文件也推送给了Browser。这是由于Server端启用了HTTP/2 Push机制，并预测判断Browser很可能会在接下来发起Get style.css和image.png两个资源的请求。这些主动推送给Browser的资源很可能是Browser所不需要的或是已经在Browser cache中存在的资源，会造成带宽资源浪费。 HTTP Server 优雅退出1.8 新增优雅退出的方法 1func (srv *Server) Shutdown(ctx context.Context) error 我们传入一个上下文，当前有未处理完的active connections。将等待处理完，当然我们也不能无限等待下去，我们可以指定上下文的超时时间。 Go 1.9该版本几点变化 引入类型别名 并行编译，速度大大提升 ./…不再匹配vendor目录 新增并发map支持sync.Map 语言新的类型别名，类型别名声明方式 1type A = B type alias并未创造新类型，只是源类型的“别名”，在类型信息上与源类型一致，因此可以直接赋值。 1A.BValue = 2 也可以使用源类型的方法，但是不能定义新方法 123A.Bfunc()func (a *A) Afunc() // Error: cannot define new methods on non-local type int 核心和标准包Sync新增并发map的支持，sync.Map结构 Database/sql如果Tx.Stmt不可用，将会使用缓存好的Stmt，这样是避免每次重新prepare MathGo 1.9提供了高性能math/bits 应对bit位的操作这个问题。 Go 1.10该版本变化不大，几点特色： 默认的GOROOT，开发者无需显式设置GOROOT环境变量，go程序会自动根据自己所在路径推导出GOROOT的路径。 通过cache实现增量构建 新的环境变量GOTMPDIR test的文件没有变化，那么test的结果会被缓存 核心和标准包Strings该包中添加了一个Builder类型，可以用来字符串拼接。降低字符串的拼接的拷贝带来的内存分配和释放的性能损失。 Go 1.11该版本添加了WebAssembly的支持，最重要是引入了包管理go moudle。启用go module 1export GO111MODULE=on 初始化项目 1go mod init your-project 此时使用go build会自动下载包依赖构建。 对于被墙的包，可以设置代理 1export GOPROXY=https://goproxy.cn Go 1.12该版本变化也很小 GO111MODULE=on时，获取go module不再显式需要go.mod，go get 时不需要创建go.mod文件了- 添加对TLS 1.3的支持，默认不开启 go安装包中移除go tour Go 1.13该版本变化也很小 GO111MODULE的默认值继续auto，但是只要当前目录包含go.mod文件或位于go.mod文件的目录下，auto设置就会激活go命令的模块 Go1.13这个版本引入了一个新的环境变量GOPRIVATE，用来指示私有的模块路径。 12# 设置不走proxy的私有仓库，多个用逗号相隔go env -w GOPRIVATE=*.corp.example.com 1.13版本提高了defer性能达30%。 语言 新增数字表示方式0b0010 （二进制）、0o1276（八进制）、0x.8p-0（十六进制浮点） 核心和标准包Syncsync包的Once.Do方法比之前快了两倍，Mutex/RWMutex方法的速度提高了10%。 Go 1.14版本主要还是标准包的修改，语言结构上略有变化。 defer性能继续提升，几乎可以忽略不计 time.After, time.Tick, net.Conn.SetDeadline 这些计时器修改减少资源竞争和上下文切换，性能提升 语言interface类型相同的方法可以覆盖了，下面的代码在1.14之前无法编译通过 123456789101112131415161718package maintype Person interface &#123; Speak()&#125;type Student interface &#123; Speak()&#125;type ChineseStudent interface &#123; Person Student&#125;func main() &#123; &#125; 1.14之前版本报错 12# command-line-arguments./interface.go:14: duplicate method Speak 工具链 1.14已经完全建议开发者使用go module版本管理。 go.mod 包中的+incompatible 标识的包本，如果模块的最新版本包含go.mod文件，则除非明确要求或已经使用该版本，否则go get将不再升级到该模块的不兼容版本。 核心和标准包crypto/tls 移除SSLv3的支持 reflect StructField元素添加PkgPath字段，StructOf支持创建未导出的字段。 hash/maphash 标准库的新成员，用与字节哈希序列化，产生的结果单处理器上是一致性的，不同的处理器将产生不同结果，且不是密码安全的。","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://diiyw.com/categories/Go语言/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://diiyw.com/tags/Golang/"}]},{"title":"使用Docker构建go程序","slug":"go-docker-builder","date":"2019-09-28T09:13:36.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/09/28/go-docker-builder/","link":"","permalink":"http://diiyw.com/2019/09/28/go-docker-builder/","excerpt":"最近公司内部Go版本需要从1.7升级到最新版，涉及项目众多。为了正式环境自动构建系统能够兼容多版本方式构建，除了使用GVM方式之外，考虑到使用Docker Go程序构建容器更加的快速，不用每次版本切换时需要重新指定GOPATH。当然升级的目的，不仅仅的性能提升，第三方包兼容等，我们也会引入Go Moudule。特此记录此次Go升级实践。","text":"最近公司内部Go版本需要从1.7升级到最新版，涉及项目众多。为了正式环境自动构建系统能够兼容多版本方式构建，除了使用GVM方式之外，考虑到使用Docker Go程序构建容器更加的快速，不用每次版本切换时需要重新指定GOPATH。当然升级的目的，不仅仅的性能提升，第三方包兼容等，我们也会引入Go Moudule。特此记录此次Go升级实践。 构建镜像我们使用官方镜像构建自己的镜像以便后续操作。 Dockerfile内容如下： 1234567891011121314151617# 最新版本构建容器FROM golang:latestMAINTAINER cheuk# 创建构建目录RUN mkdir /gobuilder# SSH配置RUN echo \"StrictHostKeyChecking no\" &gt;&gt; /etc/ssh/ssh_config# 链接替换RUN git config --global url.\"git@gitlab.xxx.com:\".insteadOf \"http://gitlab.xxxx.com/\"# 工作目录WORKDIR /gobuilder# 环境变量配置ENV GOPATH $GOPATH:/gobuilderENV GO111MODULE offENV GOPROXY \"\"# 磁盘映射packageVOLUME [\"/gobuilder\",\"/go/src\"] SSH配置自动添加key到kown_hosts文件。Go在访问私有包的时候，请求协议为http，我们替换到ssh，这样能进行免密操作。 我们使用的最新版latest构建，创建并指定了我们的工作目录/gobuilder。运行构建： 1docker build -t gobuilder 1234Sending build context to Docker daemon 2.048kB................Successfully tagged gobuilder:latest 构建成功，我们创建一个容器看一下： 1docker run --rm -it gobuilder 使用参数-it我们进入交互模式，--rm退出的自动删除容器。查看下go版本: 12root@3384acdd03c8:/gobuilder# go versiongo version go1.13.1 linux/amd64 退出，我们映射我们的go 包文件内容到容器，启动容器： 1docker run --rm -it -v ~/go/src/:/go/src gobuilder -v将本机目录~/go/src/映射到容器中的/go/src目录。查看下目录下内容 1ls /go/src/ 可以看到Go已经映射到容器。同理可以映射需要构建的项目到容器 , 并运行构建 一键构建脚本我们不能每次构建输入这一大串，我们写成一个脚本执行： 123456#!/bin/bashdocker run --rm -it \\-v $GOPATH/src:/go/src \\-v $(pwd):/gobuilder \\-v ~/.ssh/:/root/.sshgobuilder /bin/sh -c 'go mod download &amp;&amp; go build '\"$*\" 这里我们映射了ssh的证书目录，这样可以共用已配置好的git正式。将脚本保存到$GOPATH/bin/gobuilder，修改执行权限 1chmod +x $GOPATH/bin/gobuilder OK，我们可以在项目目录使用我们的构建脚本了 1gobuilder -o pack","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://diiyw.com/categories/Go语言/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://diiyw.com/tags/Golang/"},{"name":"Docker","slug":"Docker","permalink":"http://diiyw.com/tags/Docker/"}]},{"title":"Go语言参数传递是传值还是传引用","slug":"golang-function-params","date":"2019-09-26T02:32:48.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/09/26/golang-function-params/","link":"","permalink":"http://diiyw.com/2019/09/26/golang-function-params/","excerpt":"Go语言参数传递是传值还是传引用？首先我们先了解下两个概念： 传值（Pass By Value） 函数传递的总是原来这个东西的一个副本，一副拷贝。修改拷贝不会对原对象产生影响。 传引用（Pass By Reference） 函数传递的总是原来这个东西的指针引用，修改拷贝改变原对象的值。 通过上面的描述，很容易让人误认为Go语言参数传递是有传值和传引用的，恰恰相反，Go语言的参数传递是没有引用的，只有传值。如果现在你脑海里有跟我一样的迷惑请往下看个例子。","text":"Go语言参数传递是传值还是传引用？首先我们先了解下两个概念： 传值（Pass By Value） 函数传递的总是原来这个东西的一个副本，一副拷贝。修改拷贝不会对原对象产生影响。 传引用（Pass By Reference） 函数传递的总是原来这个东西的指针引用，修改拷贝改变原对象的值。 通过上面的描述，很容易让人误认为Go语言参数传递是有传值和传引用的，恰恰相反，Go语言的参数传递是没有引用的，只有传值。如果现在你脑海里有跟我一样的迷惑请往下看个例子。 123456789101112131415package mainimport \"fmt\"func main() &#123; i := 10 fmt.Printf(\"原始值的内存地址是：%p\\n\", &amp;i) modifyInt(i) fmt.Println(\"i的新值为:\", i)&#125;func modifyInt(i int) &#123; fmt.Printf(\"函数里接收到的地址是：%p\\n\", &amp;i) i = 2&#125; 运行这段代码，输出结果： 123原始值的内存地址是：0xc000014088函数里接收到的地址是：0xc000014090i的新值为: 10 这里的地址每次运行结果都会不一样，但是我们可以看出来，此时函数内的i是一份拷贝，有了一个新地址。修改他并不会影响原值。继续修改下代码如下： 123456789101112131415package mainimport \"fmt\"func main() &#123; i := 10 fmt.Printf(\"原始值的内存地址是：%p\\n\", &amp;i) modifyInt(&amp;i) fmt.Println(\"i的新值为:\", i)&#125;func modifyInt(i *int) &#123; fmt.Printf(\"函数里接收到的地址是：%p\\n\", &amp;i) *i = 2&#125; 运行代码，输出结果： 123原始值的内存地址是：0xc000082008函数里接收到的地址是：0xc000090010i的新值为: 2 值改变了！不是只传值吗， 怎么现在又可以传引用？如果不幸入坑，继续往下看，首先我们来看函数参数i是什么类型，指针！那么&amp;i，没错就是指针的指针，我们打印一下原始指针的地址.。 1234567891011121314151617package mainimport \"fmt\"func main() &#123; i := 10 fmt.Printf(\"原始值的内存地址是：%p\\n\", &amp;i) ip := &amp;i fmt.Printf(\"原始指针的内存地址是：%p\\n\", &amp;ip) modifyInt(ip) fmt.Println(\"i的新值为:\", i)&#125;func modifyInt(i *int) &#123; fmt.Printf(\"函数里接收到的指针地址是：%p\\n\", &amp;i) *i = 2&#125; 输出结果： 1234原始值的内存地址是：0xc000080008原始指针的内存地址是：0xc000090010函数里接收到的指针地址是：0xc00000e018i的新值为: 2 可以看出函数中拷贝了一份新的指针，用图表示如下： 验证代码： 12345678910111213141516171819202122package mainimport ( \"fmt\" \"unsafe\")func main() &#123; i := 10 fmt.Printf(\"原始值的内存地址是：%p\\n\", &amp;i) ip := &amp;i fmt.Printf(\"原始指针的内存地址是：%p\\n\", &amp;ip) fmt.Printf(\"原始指针实际值是：%v\\n\", unsafe.Pointer(ip)) modifyInt(ip) fmt.Println(\"i的新值为:\", i)&#125;func modifyInt(i *int) &#123; fmt.Printf(\"函数里接收到的指针地址是：%p\\n\", &amp;i) fmt.Printf(\"函数里实际指针值是：%v\\n\", unsafe.Pointer(i)) *i = 2&#125; 输出结果： 123456原始值的内存地址是：0xc000088000原始指针的内存地址是：0xc000082018原始指针实际值是：0xc000088000函数里接收到的指针地址是：0xc000094000函数里实际指针值是：0xc000088000i的新值为: 2 可以看出函数里和函数外的指针的值存储的是原始值的指针地址。 结论：Go语言参数传递是传值。需要注意的是Go中的map、channel、slice都隐含一项指针，传值也是把指针传进去了，所以也是会修改到原值。","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://diiyw.com/categories/Go语言/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://diiyw.com/tags/Golang/"}]},{"title":"Redis命令行通讯协议","slug":"redis-proto","date":"2019-09-19T05:58:57.000Z","updated":"2021-05-25T09:59:36.091Z","comments":true,"path":"2019/09/19/redis-proto/","link":"","permalink":"http://diiyw.com/2019/09/19/redis-proto/","excerpt":"Redis客户端通过RESP（REdis Serialization Protocol ）协议与服务端通讯。Redis集群是则是通过另一协议来处理节点间的通讯。 RESP有以下特点： 简单且容易实现 能够快速解析 可读的 RESP 能够序列化各种类型，包括整形，字符串，数组，错误类型. 客户端连接服务端的数据是以字符串数组的形式发送给服务端，相当于命令的参数形式。Redis 响应命令执行结果数据. RESP 是二进制安全的，不需要从一个进程传送大量的数据，因为使用了前缀长度（prefixed-length）传送数据。","text":"Redis客户端通过RESP（REdis Serialization Protocol ）协议与服务端通讯。Redis集群是则是通过另一协议来处理节点间的通讯。 RESP有以下特点： 简单且容易实现 能够快速解析 可读的 RESP 能够序列化各种类型，包括整形，字符串，数组，错误类型. 客户端连接服务端的数据是以字符串数组的形式发送给服务端，相当于命令的参数形式。Redis 响应命令执行结果数据. RESP 是二进制安全的，不需要从一个进程传送大量的数据，因为使用了前缀长度（prefixed-length）传送数据。 二进制安全二进制化的字符串,不关心具体格式.只会严格的按照二进制的数据存取。不会妄图已某种特殊格式解析数据。也就是二进制安全的字符串是只有一种正确解。 网络层Redis使用TCP进行客户端的连接，但是技术上不完全依赖TCP，更像是 Unix sockets Unix socketsUnix Domain Socket 是在Socket架构上发展起来的用于同一台主机的进程间通讯（IPC）。它不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序列号应答等。只是将应用层数据从一个进程拷贝到另一个进程。Unix Domain Socket有SOKCET_DGRAM和SOCKET_STREAM两种模式，类似于UDP和TCP，但是面向消息的Unix socket也是可靠的，消息既不会丢失也不会顺序错乱。比如的mysql socket文件：/tmp/mysql.sock, 直接操作该文件就可以与mysql通讯。 请求响应模型Redis使用的是最简单的协议，接收一个命令参数时，会立即执行该命令并返回执行结果数据。 除以下情况，Redis都是通过这种简单协议通讯: Redis 支持管道操作。导致一次性会有很多的命令发送后需要等待返回 Redis订阅了一个Pub/Sub 频道，redis将更改协议语义，此时转变成了push协议。客服端不在发送指令，而是由服务端发送数据到客户端。 RESP 协议描述RESP实际上就是一个序列化协议。支持简单字符串、错误、整形，批量字符串和数组类型。 Redis 的请求响应协议方式有以下两种: 所有客户端发送到服务端的命令都是一个字符串数组. Redis根据指令的执行结果，回复一个相应的数据类型 RESP 通过第一个个字节来标记数据类型: + 标记字符串 - 标记错误类型 : 标记整形 $ 标记批量字符串 * 标记数据类型 RESP 总是以\\r\\n (CRLF)为结束符。 简单字符串简单字符串,及非二进制安全的字符串。使用+ 开始标记： 1&quot;+OK\\r\\n&quot; 如果要发送二进制安全的字符串，则需要通过字符串数组方式。 错误类型与简单字符串类似，不过是以-开头。如 1&quot;-Error message\\r\\n&quot; 只有在发生错误时才会返回错误。 1-ERR unknown command &apos;foobar&apos; 1-WRONGTYPE Operation against a key holding the wrong kind of value ERR，WRONGTYPE 是错误类型前缀，以便区分不同的错误类型，ERR是基本的错误类型。 整形以:开头，例如： 1&quot;:0\\r\\n&quot; 1&quot;:1000\\r\\n&quot; 多用与INCR,LLEN,LASTSAVE等命令。整形的1,0可以用来表示真假。也可以用来表示指令是否成功执行 字符串数组（Bulk Strings）用来传送二进制安全的字符串，高达512M长度的发送。 通过以下方式进行编码： 以$开头接收一个长度的数字,拼接上CFLR\\r\\n 再次连接实际的字符串 以CFLR结束1&quot;$6\\r\\nfoobar\\r\\n&quot; 特别的空表示方式如下： 1&quot;$0\\r\\n\\r\\n&quot; Null表示方式如下: 1&quot;$-1\\r\\n&quot; 以上两种特别情况下，不同的API库不会返回一个可空的字符串，不同语言的封装包，中例如Ruby返回nil对象，C语言放回Null。 数组LRANGE 命令返回的就是数组格式。 通过以下方式格式化： 以*开头跟上数组的长度，以CRLF结尾。 1&quot;*0\\r\\n&quot; 数组元素是可选的 1&quot;*2\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n&quot; 表示两个数组，由两个字符串$3\\r\\nfoo\\r\\n,$3\\r\\nbar\\r\\n组成。数据可以进行类型混合 1234567*5\\r\\n:1\\r\\n:2\\r\\n:3\\r\\n:4\\r\\n$6\\r\\nfoobar\\r\\n 为了清晰可见这里做了换行处理。 特别的，Null数组表示方式： 1&quot;*-1\\r\\n&quot; 数组的元素支持Null，如： 123456*3\\r\\n$3\\r\\nfoo\\r\\n$-1\\r\\n$3\\r\\nbar\\r\\n 为了清晰可见这里做了换行处理。不同语言包处理的结果不同，可能是一下结果： 1[\"foo\",null,\"bar\"] 1[\"foo\",nil,\"bar\"] 原理实践 客服端发送字符串数组到服务端 服务端根据实际执行结果返回内容 如果我们要执行LLEN mylist则客户端发送: 12345*2\\r\\n$4\\r\\nLLEN\\r\\n$6\\r\\nmylist\\r\\n 为了清晰可见这里做了换行处理,实际上发送的不能进行换行处理，实际发送内容是 1*2\\r\\n$4\\r\\nLLEN\\r\\n$6\\r\\nmylist\\r\\n 服务端返回: 1&quot;:3445\\r\\n&quot; 多命令管道化客户端可以在一个连接上提交多个命令，管道提供了一个可以一次提交多个命令的方法。 内联命令如果我们手头上的没有redis-cli工具，只有telnet或者单纯的其他TCP连接工具，那么我么可以使用内联命令使用redis 1telnet 127.0.0.1 6379 输入PING 12345Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.PING+PONG 例如可输入得到结果: 12EXISTS somekey:0","categories":[{"name":"Redis","slug":"Redis","permalink":"http://diiyw.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://diiyw.com/tags/Redis/"}]}]}