<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解Go的Channel (待更新)</title>
      <link href="/2021/05/01/inner-understanding-go-channels/"/>
      <url>/2021/05/01/inner-understanding-go-channels/</url>
      
        <content type="html"><![CDATA[<p>Go语言中通过goroutines和channel进行并发的控制。</p><ul><li>goroutines 提供了独立任务的并发/并行可能</li><li>channel 提供goroutines间交流、同步的桥梁</li></ul><p>理解Channel用法，参考这篇文章 <a href="http://diiyw.com/2019/10/24/go-channel-buffer/">《Go语言Channel的Buffered与Unbuffered》</a> ，总结channel有一下的特点：</p><ul><li>保证goroutines并发安全</li><li>提供FIFO（先进先出）的特性</li><li>可以在goroutines传送和存储值</li><li>可以控制goroutines阻塞和非阻塞（控制执行和停止等待）</li></ul><p>所以，我们需要从底层去了解channel的结构，channel 底层是一个hchan的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// 队列数据总数</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// 循环队列的大小</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 指向dataqsiz大小的数组元素地址</span></span><br><span class="line">elemsize <span class="keyword">uint16</span></span><br><span class="line">closed   <span class="keyword">uint32</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// 发送索引</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// 接收索引</span></span><br><span class="line">recvq    waitq  <span class="comment">// 接收等待的队列</span></span><br><span class="line">sendq    waitq  <span class="comment">// 发送等待的队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">  <span class="comment">// 锁</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不去关注具体的字段意义，我们从最基本的出发</p><a id="more"></a><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go的坑点记录 （持续记录）</title>
      <link href="/2021/04/27/go-special-pit/"/>
      <url>/2021/04/27/go-special-pit/</url>
      
        <content type="html"><![CDATA[<h2 id="Go的变量传参是值传递"><a href="#Go的变量传参是值传递" class="headerlink" title="Go的变量传参是值传递"></a>Go的变量传参是值传递</h2><p>这边文章有具体分析：《<a href="http://diiyw.com/2019/09/26/golang-function-params/">Go语言参数传递是传值还是传引用</a>》,看一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">foo(i)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">boo(i)</span><br><span class="line"><span class="comment">// 没有输出 1 0 0 3 4 5</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1 0 0]</span><br><span class="line">[1 0 0]</span><br></pre></td></tr></table></figure><a id="more"></a><p>第二段输出并不是[1 0 0 3 4 5]，切片是引用类型，但是并不是引用传递。Go底层中如果切片没有扩容，修改的结果将应用到原值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Defer 中包含panic，panic仅有最后一个可以被revover捕获</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">// 无法被捕获</span><br><span class="line">panic(&quot;defer panic 1&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">if err := recover(); err != nil&#123;</span><br><span class="line">fmt.Println(&quot;receive: &quot;,err)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">fmt.Println(&quot;fatal&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">// 被recover捕获</span><br><span class="line">panic(&quot;defer panic 2&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">panic(&quot;defer panic 3&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">// 这里的会被替换</span><br><span class="line">panic(&quot;panic here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>defer的执行顺序是先进后出。输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">receive:  defer panic 2</span><br><span class="line">panic: defer panic 1</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main.func1()</span><br><span class="line">        /Users/xxx/workspace/testing/go/main.go:11 +0x39</span><br><span class="line">main.main()</span><br><span class="line">        /Users/xxx/workspace/testing/go/main.go:32 +0x99</span><br></pre></td></tr></table></figure><p>触发<code>panic(&quot;panic&quot;)</code>后defer顺序出栈执行，第一个被执行的defer中 会有<code>panic(&quot;defer panic 3&quot;)</code>异常语句，这个异常将会覆盖掉main中的异常<code>panic(&quot;panic&quot;)</code>，第三个defer会替换掉panic(“defer panic 3”)，这个异常被第二个执行的defer捕获到。第一个无法被捕获程序崩溃。</p><h2 id="Go中可以调用类型赋值为nil的属性方法"><a href="#Go中可以调用类型赋值为nil的属性方法" class="headerlink" title="Go中可以调用类型赋值为nil的属性方法"></a>Go中可以调用类型赋值为nil的属性方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">new</span>(Foo)</span><br><span class="line">fmt.Println(f)</span><br><span class="line">f = <span class="literal">nil</span></span><br><span class="line">f.A()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;&#125;</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>程序并不会奔溃。这事什么原因呢？Google中找到一段说明</p><p>In Go the function to be called by the Expression.Name() syntax is entirely determined by the type of Expression and not by the particular run-time value of that expression, including nil.</p><p>对象方法是不在运行时确定的（编译时已经确定），所以运行时对象的nil，并不会导致panic;</p><h2 id="struct-是个空类型"><a href="#struct-是个空类型" class="headerlink" title="struct{} 是个空类型"></a>struct{} 是个空类型</h2><p>struct{} 是个空类型，所有struct{} 指向同一个零地址，可以用于channel的信号传送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> foo2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := <span class="built_in">new</span>(foo1)</span><br><span class="line">f2 := <span class="built_in">new</span>(foo2)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, f1)</span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, f2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论执行多少次，同台电脑都会输出相同的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x118e370</span><br><span class="line">0x118e370</span><br></pre></td></tr></table></figure><h2 id="不要用共享内存进行协程通讯"><a href="#不要用共享内存进行协程通讯" class="headerlink" title="不要用共享内存进行协程通讯"></a>不要用共享内存进行协程通讯</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">you := <span class="string">"bar are you"</span></span><br><span class="line">foo := <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line">str := <span class="string">""</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> flag &#123;</span><br><span class="line">str = you</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">str = foo</span><br><span class="line">&#125;</span><br><span class="line">flag = !flag</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> str == <span class="string">"bar"</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"bar"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(str)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码运行一段时间后，会panic. 说明string 类型其实不是线程安全的。str内部结构包含len、data 两个字段，先修改了data，在没有修改len情况下，取值将取的是str的len长度的字符串，所以上述代码会panic。当然这也违背了Go语言：”不要通过共享内存来通信，而应该通过通信来共享内存”。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lumen/Laravel Model 操作</title>
      <link href="/2020/11/10/lumen-model-tutorials/"/>
      <url>/2020/11/10/lumen-model-tutorials/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Lumen的Model操作使用的是 Laravel 内置的 Eloquent ORM，Eloquent提供了一个美观、简单的与数据库打交道的 ActiveRecord 实现，每张数据表都对应一个与该表进行交互的模型（Model），通过模型类，你可以对数据表进行查询、插入、更新、删除等操作。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>应用的数据库配置位于 <code>config/database.php</code>（但是数据库用户及密码等敏感信息位于 <code>.env</code> 文件）。在该文件中你可以定义所有的数据库连接，并指定哪个连接是默认连接。该文件中提供了所有支持数据库系统的配置示例。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env(<span class="string">'DB_CONNECTION'</span>, <span class="string">'mysql'</span>) <span class="comment">// 配置文件中通过env()获取.env文件中配置的键值</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><p>模型定义的目录app\Models</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestModel</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 指定连接名称</span></span><br><span class="line">    <span class="comment">// config/databases.php中的mysql索引项。</span></span><br><span class="line">    <span class="keyword">protected</span> $connection = <span class="string">"mysql"</span></span><br><span class="line">    <span class="comment">// 定义表名</span></span><br><span class="line">    <span class="keyword">protected</span> $table = <span class="string">"test"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义默认主键，默认是id，如果是其他值这里需要修改</span></span><br><span class="line">    <span class="keyword">protected</span> $primaryKey = <span class="string">"id"</span>;</span><br><span class="line">    <span class="comment">// 这里是主键的类型，默认int如果是非int类型就需要修改</span></span><br><span class="line">    <span class="keyword">protected</span> $keyType = <span class="string">'int'</span>;</span><br><span class="line">    <span class="comment">// 主键是否是自增的配置</span></span><br><span class="line">    <span class="keyword">public</span> $incrementing = <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 表明模型是否应该被打上时间戳，这个功能可以让ORM自动为我们的时间字段自动更新配置上时间</span></span><br><span class="line">    <span class="comment">// 配合CREATED_AT 使用 UPDATED_AT使用</span></span><br><span class="line">    <span class="comment">// 默认开启，如果不实用该功能配置false</span></span><br><span class="line">    <span class="keyword">public</span> $timestamps = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// CREATED_AT、UPDATED_AT配置常量可以自定义自己的字段名称</span></span><br><span class="line">    <span class="keyword">const</span> CREATED_AT = <span class="string">'created_at'</span>;</span><br><span class="line">    <span class="keyword">const</span> UPDATED_AT = <span class="string">'updated_at'</span>;</span><br><span class="line">    <span class="comment">// 当然也可以指定保存的时间格式</span></span><br><span class="line">    <span class="comment">// 这里可接受的值跟date()的接受的值是一致的。</span></span><br><span class="line">    <span class="comment">// 文档 https://www.php.net/manual/zh/function.date.php</span></span><br><span class="line">    <span class="keyword">protected</span> $dateFormat = <span class="string">'U'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模型CRUD"><a href="#模型CRUD" class="headerlink" title="模型CRUD"></a>模型CRUD</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>在Contoller，Service层等可以直接调用模型方法</p><h4 id="获取全部数据"><a href="#获取全部数据" class="headerlink" title="获取全部数据"></a>获取全部数据</h4><p><code>all()</code>返回所有数据，如果数据存在返回对象<code>\Illuminate\Database\Eloquent\Collection</code> 可以使用<code>toArray()</code>方法输出为数组格式。如果没有数据放回空数组。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$data = TestModel::all();</span><br><span class="line">$data-&gt;toArray();</span><br></pre></td></tr></table></figure><h4 id="获取一条数据"><a href="#获取一条数据" class="headerlink" title="获取一条数据"></a>获取一条数据</h4><p><code>first()</code> 如果找到了数据返回的是个对象, 可以使用<code>toArray()</code>方法输出为数组格式，如果找不到数据返回<code>null</code>;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$data = TestModel::first();</span><br><span class="line">$data-&gt;toArray();</span><br></pre></td></tr></table></figure><h4 id="获取多条数据"><a href="#获取多条数据" class="headerlink" title="获取多条数据"></a>获取多条数据</h4><p><strong>注意：</strong> 无论查询结果是否为空，<code>get()</code>方法都放回一个对象，如果使用empty() 检测一定都是<code>false</code>;所以可以完全直接调用<code>toArray()</code>，这一点和<code>first()</code>是不一样的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$data = TestModel::get();</span><br><span class="line">$data-&gt;toArray();</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果对结果集对象遍历</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">foreach</span>($data <span class="keyword">as</span> $v) &#123;</span><br><span class="line">    <span class="comment">// 这里的$v是个stdClass对象</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="查询指定字段"><a href="#查询指定字段" class="headerlink" title="查询指定字段"></a>查询指定字段</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;first();</span><br><span class="line"><span class="comment">// 多个字段</span></span><br><span class="line">$data = TestModel::select(<span class="string">"name"</span>,<span class="string">"status"</span>)-&gt;first();</span><br></pre></td></tr></table></figure><p>如果要对字段进行表达式处理</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个字段</span></span><br><span class="line">$data = TestModel::selectRaw(<span class="string">"name,status"</span>)-&gt;first();</span><br><span class="line"><span class="comment">// 复杂查询</span></span><br><span class="line">$data = TestModel::selectRaw(<span class="string">"CASE name WHEN 1 THEN 1 ELSE -1 END name"</span>)-&gt;first();</span><br></pre></td></tr></table></figure><h4 id="Where条件"><a href="#Where条件" class="headerlink" title="Where条件"></a>Where条件</h4><p>where条件大都封装好了，可以使用whereXXX()调用，如<code>whereIn()</code>、<code>whereBetween</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;where(<span class="string">"status"</span>,<span class="number">1</span>)-&gt;first();</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;where(<span class="string">"status"</span>,<span class="string">"="</span>,<span class="number">1</span>)-&gt;first();</span><br><span class="line"><span class="comment">// in 查询</span></span><br><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;whereIn(<span class="string">"status"</span>,[<span class="number">1</span>,<span class="number">-1</span>])-&gt;first();</span><br><span class="line"><span class="comment">// between</span></span><br><span class="line"><span class="comment">// select name from `test` where `status` = ? and `status` between ? and ?</span></span><br><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;where(<span class="string">"name"</span>,<span class="string">"hello"</span>)-&gt;whereBetween(<span class="string">"status"</span>,[<span class="number">1</span>,<span class="number">-1</span>])-&gt;first();</span><br><span class="line"><span class="comment">// between </span></span><br><span class="line"><span class="comment">// select name from `test` where `status` = ? or `status` between ? and ?</span></span><br><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;where(<span class="string">"name"</span>,<span class="string">"hello"</span>)-&gt;whereBetween(<span class="string">"status"</span>,[<span class="number">1</span>,<span class="number">-1</span>],<span class="string">"or"</span>)-&gt;first();</span><br><span class="line"><span class="comment">// between </span></span><br><span class="line"><span class="comment">// select name from `test` where `status` = ? or `status` not between ? and ?</span></span><br><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;where(<span class="string">"name"</span>,<span class="string">"hello"</span>)-&gt;whereBetween(<span class="string">"status"</span>,[<span class="number">1</span>,<span class="number">-1</span>],<span class="string">"or"</span>,<span class="keyword">true</span>)-&gt;first();</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;orWhere(<span class="string">"status"</span>,<span class="string">"="</span>,<span class="number">1</span>)-&gt;first();</span><br></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;orWhere(<span class="string">"status"</span>,<span class="string">"="</span>,<span class="number">1</span>)-&gt;offset(<span class="number">0</span>)-&gt;limit(<span class="number">10</span>)-&gt;get();</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;orWhere(<span class="string">"status"</span>,<span class="string">"="</span>,<span class="number">1</span>)-&gt;skip(<span class="number">10</span>)-&gt;limit(<span class="number">10</span>)-&gt;get();</span><br></pre></td></tr></table></figure><h4 id="自动分页"><a href="#自动分页" class="headerlink" title="自动分页"></a>自动分页</h4><p>Eloquent ORM 内置一个非常方便的自动分页处理函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要传入每页条数， Eloquent自动帮你处理分页数据。指定页数是参数`page`可以修改自己的名称。</span></span><br><span class="line">$users = TestModel::select(<span class="string">"name"</span>)-&gt;paginate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>$users是一个分页对象，可以使用 <code>appends</code> 方法增加搜索字串到分页链接中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$users-&gt;appends([<span class="string">'sort'</span> =&gt; <span class="string">'votes'</span>]);</span><br></pre></td></tr></table></figure><p>这样会产生类似下列的链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/something?page=2&amp;sort=votes</span><br></pre></td></tr></table></figure><p>如果您想要将「哈希片段」加到分页的 URL，您可以使用 <code>fragment</code> 方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$users-&gt;fragment(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><p>此方法调用后将产生 URL，看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/something?page=2#foo</span><br></pre></td></tr></table></figure><p><code>setPath</code> 方法自定义使用的 URL：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$users-&gt;setPath(<span class="string">'http://domain/path'</span>);</span><br></pre></td></tr></table></figure><h4 id="Join连表查询"><a href="#Join连表查询" class="headerlink" title="Join连表查询"></a>Join连表查询</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$data = TestModel::select(<span class="string">"name"</span>)-&gt;leftJoin(<span class="string">"user"</span>,<span class="string">"user.id"</span>,<span class="string">"="</span>,<span class="string">"test.id"</span>)-&gt;first();</span><br></pre></td></tr></table></figure><h4 id="Count等聚合查询"><a href="#Count等聚合查询" class="headerlink" title="Count等聚合查询"></a>Count等聚合查询</h4><p>直接返回整型数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestModel::count();</span><br><span class="line">TestModel::max(<span class="string">"price"</span>);</span><br></pre></td></tr></table></figure><h4 id="分组与排序"><a href="#分组与排序" class="headerlink" title="分组与排序"></a>分组与排序</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$data = TestModel::orderBy(<span class="string">"id"</span>,<span class="string">"desc"</span>)-&gt;first();</span><br><span class="line">$data = TestModel::orderBy(<span class="string">"id"</span>,<span class="string">"desc"</span>)-&gt;groupBy(<span class="string">"city"</span>)-&gt;first();</span><br></pre></td></tr></table></figure><h4 id="执行原生语句"><a href="#执行原生语句" class="headerlink" title="执行原生语句"></a>执行原生语句</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法返回一个二维数组、数组元素是一个stdClass对象。查询不到数据返回空数组。</span></span><br><span class="line">DB::connection(<span class="string">"mysql"</span>)-&gt;select(<span class="string">"select * from user where status=? limit 1"</span>,[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 或者，返回与上面的一致</span></span><br><span class="line">$data = (<span class="keyword">new</span> TestModel())-&gt;getConnection()-&gt;select(<span class="string">"select * from user where status=? limit 1"</span>,[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回布尔值，成功或者失败 </span></span><br><span class="line">$success = TestModel::insert([<span class="string">"namae"</span> =&gt; <span class="string">"john"</span>]);</span><br><span class="line"><span class="comment">// 返回自增ID的值</span></span><br><span class="line">$id = TestModel::insertGetId([<span class="string">"namae"</span> =&gt; <span class="string">"john"</span>]);</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回受影响的行数</span></span><br><span class="line">$rowEffect = TestModel::where(<span class="string">"id"</span>,<span class="number">1</span>)-&gt;update([<span class="string">"status"</span>=&gt;<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">$model =  TestModel::find($id);</span><br><span class="line">$model-&gt;status = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 返回布尔值</span></span><br><span class="line">$model-&gt;save();</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回删除影响数</span></span><br><span class="line">$delete = TestModel::where(<span class="string">"id"</span>,<span class="number">1</span>)-&gt;delete();</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务的三个方法<code>beginTransaction</code>,<code>commit</code>,<code>rollBack</code>返回的都是<code>NULL</code>，出错必须用try catch结构包裹处理异常错误；</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">DB::beginTransaction();</span><br><span class="line"> <span class="comment">// todo something</span></span><br><span class="line">  DB::commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">  DB::rollBack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TestModel::beginTransaction();</span><br><span class="line"> <span class="comment">// todo something</span></span><br><span class="line">  TestModel::commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">  TestModel::rollBack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>chuck处理大批量查询数据，减少内存占用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestModel::chunk(<span class="number">100</span>,<span class="function"><span class="keyword">function</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">  <span class="comment">// todo something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用<code>cursor()</code>逻辑过滤</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论有无结果集均返回的是集合对象，可以使用toArray()s</span></span><br><span class="line">$result = TestModel::cursor()-&gt;filter(<span class="function"><span class="keyword">function</span> <span class="params">($test)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $test-&gt;id &gt; <span class="number">500</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>pluck返回指定字段的值数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回集合对象，无论是否有记录都返回集合对象，toArray()如果为空就是返回空数组。</span></span><br><span class="line">$result = TestModel::where(<span class="string">"id"</span>,<span class="string">"&gt;="</span>,<span class="number">1</span>)-&gt;pluck(<span class="string">"id"</span>);</span><br><span class="line"><span class="comment">// 可以使用toArray()转换成数组</span></span><br><span class="line">$data = $resut=&gt;toArray();</span><br><span class="line"><span class="comment">// [1,2,3,4,.....]</span></span><br></pre></td></tr></table></figure><p>与<code>get(&#39;id&#39;)</code>返回结果的区别：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$getResult = TestModel::get(<span class="string">"id"</span>)-&gt;toArray();</span><br><span class="line">$pluckResult = TestModel::pluck(<span class="string">"id"</span>)-&gt;toArray();</span><br></pre></td></tr></table></figure><p><code>$getResult</code> 结果:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span> (</span><br><span class="line">  <span class="number">0</span> =&gt; </span><br><span class="line">  <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'id'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">  ),</span><br><span class="line">  <span class="number">1</span> =&gt; </span><br><span class="line">  <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'id'</span> =&gt; <span class="number">2</span>,</span><br><span class="line">  ),</span><br><span class="line">  <span class="number">2</span> =&gt; </span><br><span class="line">  <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'id'</span> =&gt; <span class="number">3</span>,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>$pluckResult</code> 结果:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span> (</span><br><span class="line">  <span class="number">0</span> =&gt; <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span> =&gt; <span class="number">2</span>,</span><br><span class="line">  <span class="number">2</span> =&gt; <span class="number">3</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>pluck可以指定数据中的某个字段值作为键，假设数据库结构</p><table><thead><tr><th>Id</th><th>status</th></tr></thead><tbody><tr><td>1</td><td>Off</td></tr><tr><td>2</td><td>On</td></tr><tr><td>3</td><td>Freeze</td></tr></tbody></table><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pluckResult = TestModel::pluck(<span class="string">"id"</span>,<span class="string">"status"</span>)-&gt;toArray();</span><br></pre></td></tr></table></figure><p>则最终结果输出：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span> (</span><br><span class="line">  <span class="string">"off"</span> =&gt; <span class="number">1</span>,</span><br><span class="line">  <span class="string">"On"</span> =&gt; <span class="number">2</span>,</span><br><span class="line">  <span class="string">"Freeze"</span> =&gt; <span class="number">3</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>toSql查看构造器最终的SQL语句</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestModel::toSql();</span><br><span class="line">TestModel::where(<span class="string">"id"</span>,<span class="string">"&gt;="</span>,<span class="number">1</span>)-&gt;toSql();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大部分sql的关键字的表达方式，Eloquent都已经实现，IDE输入关键字可自动提示！对于复杂SQL比如使用了聚合函数等，Eloquent都提供了xxxRaw()的方法。比如：selectRaw，whereRaw灵活应用。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socks4(a)\5协议</title>
      <link href="/2020/06/20/socks-procotol/"/>
      <url>/2020/06/20/socks-procotol/</url>
      
        <content type="html"><![CDATA[<p>传统的网络是一个C\S架构，相当于直连接网络</p><p><img alt="image-20200618170723322" data-src="/images/image-20200618170723322.png"></p><p>有一天，网络服务提供商为了限制使用者访问某些互联网服务，于是设置了一堵墙，只有符合规则的网络传输才允许通过。目前全球最大，最厉害的是GFW，但是也做不到完全限制墙外访问，于是有人就找了台墙外主机，作为代理，所有墙内请求都需经过该主机经转发后访问具体目标，这样就可以在墙外轻松享受服务。</p><a id="more"></a><p><img alt="image-20200618171313651" data-src="/images/image-20200618171313651.png"></p><p>Socks协议至此衍生出来。</p><p>Socks是会话层的协议，位于表示层与传输层之间。目前有两个版本的协议。</p><h2 id="Socks4-a"><a href="#Socks4-a" class="headerlink" title="Socks4(a)"></a>Socks4(a)</h2><p>主要有以下几个RFC标准：</p><blockquote><p><a href="http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol" target="_blank" rel="noopener">http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol</a><br><a href="http://www.rfc-editor.org/rfc/rfc1928.txt" target="_blank" rel="noopener">http://www.rfc-editor.org/rfc/rfc1928.txt</a><br><a href="http://www.smartftp.com/Products/SmartFTP/RFC/socks4a.protocol" target="_blank" rel="noopener">http://www.smartftp.com/Products/SmartFTP/RFC/socks4a.protocol</a></p></blockquote><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><p>发送请求报文，报文结构如下所示，由五段组成，数字代表占用字节数</p><ul><li><code>VER</code> 版本号：固定是 0x04</li><li><code>CMD</code> 说明此次需要执行什么操作</li><li><code>PORT</code> 告诉代理我需要访问的墙外资源的端口</li><li><code>IP</code> 告诉代理需要访问的墙外资源的IP</li><li><code>USERID</code> 一个标识ID，用于代理验证合法性的请求，可选项</li><li><code>NULL</code>  结束符占用一个字节</li></ul></li></ol><p><img alt="image-20200618171334213" data-src="/images/image-20200618171334213.png"></p><ol start="2"><li>服务端接收到请求，响应报文如下，其中<code>PORT</code>和<code>IP</code>可填充0，在某些客户端中不能去掉这两项参数，长度需要为8字节。响应之后服务端与<code>IP:PORT</code>建立连接，并直接绑定到客户端到服务端的连接中，后续服务端将不参与其中。</li></ol><p><img alt="image-20200618171354514" data-src="/images/image-20200618171354514.png"></p><p> Socks4a的请求报文就不过多解释了，增加了域名解析的传参，是对Socks4的补充，如下所示：</p><p><img alt="image-20200618171419445" data-src="/images/image-20200618171419445.png"></p><h2 id="Socks5"><a href="#Socks5" class="headerlink" title="Socks5"></a>Socks5</h2><p>主要有以下几个RFC标准:</p><blockquote><p><a href="https://tools.ietf.org/html/rfc1929" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1929</a></p><p><a href="https://tools.ietf.org/html/rfc1961" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1961</a></p><p><a href="https://tools.ietf.org/html/rfc3089" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc3089</a></p></blockquote><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol><li><p>socks5的请求报文只有三个参数</p><ul><li><code>VER</code>是版本号，固定0x05</li><li><code>NMETHODS</code> 是表示<code>METHODS</code>的长度</li><li><code>METHODS</code>验证方法，因为<code>NMETHODS</code>最大值只能是255所以参数最大字节数是255</li></ul></li></ol><p><img alt="image-20200618171501454" data-src="/images/image-20200618171501454.png"></p><ol start="2"><li><p>服务端返回响应报文就很简单了</p><ul><li><code>VER</code> 是版本号固定 0x05</li><li><code>METHOD</code> 服务端选择一个自己也支持的认证方案返回</li></ul></li></ol><p><img alt="image-20200619153538912" data-src="/images/image-20200619153538912.png"></p><ol start="3"><li><p>校验通过，客服端继续发起第二次请求报文</p><ul><li><code>VER</code> 版本号，固定0x05</li><li><code>CMD</code> 需要服务端做出的操作指令</li><li><code>RSV</code> 是保留位，值是 <code>0x00</code></li><li><code>ATYP</code> 是目标地址类型</li><li><code>ADDR</code> 就是目标地址</li><li><code>PORT</code> 两个字节代表端口号</li></ul></li></ol><p><img alt="image-20200619155855845" data-src="/images/image-20200619155855845.png"></p><ol start="4"><li>服务端接收到请求，返回响应报文，同时绑定连接<ul><li><code>REP</code> 响应状态码</li><li><code>RSV</code> 保留位，值是 <code>0x00</code></li><li><code>ATYP</code> 是目标地址类型</li><li><code>ADDR</code> 就是目标地址的值了，如果是IPv4，那么就是4 bytes，如果是IPv6那么就是16 bytes，如果是域名，那么第一个字节代表 接下来有多少个字节是表示目标地址</li><li><code>PORT</code> 两个字节代表端口号</li></ul></li></ol><p><img alt="image-20200619160343681" data-src="/images/image-20200619160343681.png"></p><p>Socks5 支持UDP转发，应用场景更加广阔。</p><p>不过，现在的Socks4\5代理协议已经不再建议在广域网使用了，GFW的强大超乎你的现象，SS和Socks已没有什么用武之地了。为了免疫GFW的特征提取，新的协议将会是新的加密性质进行传输，同时也更加符合现代网络的组织结构，socks只是本地一个转换配角。Vmess才是目前受到广泛使用协议。</p><p>[附] Go语言的一个简单socks4/5实现 <a href="https://github.com/diiyw/mep" target="_blank" rel="noopener">https://github.com/diiyw/mep</a></p><p><img alt="image-20200618171635748" data-src="/images/image-20200618171635748.png"></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socks4(a) </tag>
            
            <tag> socks5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的消息系统</title>
      <link href="/2020/04/10/redis-message-system/"/>
      <url>/2020/04/10/redis-message-system/</url>
      
        <content type="html"><![CDATA[<h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2><p>所谓消息系统就是消息在发布者（Publishers）和订阅者（Subscribers）之间的传递规则，发布者不关心消息到底需要被谁接收使用，订阅者也不需要关心消息来自哪个发布者。发布者和订阅者之间通过频道（channels）来进行消息传递，发布者可以发布消息到多个频道中，而订阅者只会订阅感兴趣的频道。这样的解耦可以使得我们的网络拓扑结构更具扩展性。</p><p>Redis中提供了以下的命令，可实现消息系统</p><blockquote><ul><li><a href="https://redis.io/commands/psubscribe" target="_blank" rel="noopener">PSUBSCRIBE</a></li><li><a href="https://redis.io/commands/publish" target="_blank" rel="noopener">PUBLISH</a></li><li><a href="https://redis.io/commands/pubsub" target="_blank" rel="noopener">PUBSUB</a></li><li><a href="https://redis.io/commands/punsubscribe" target="_blank" rel="noopener">PUNSUBSCRIBE</a></li><li><a href="https://redis.io/commands/subscribe" target="_blank" rel="noopener">SUBSCRIBE</a></li><li><a href="https://redis.io/commands/unsubscribe" target="_blank" rel="noopener">UNSUBSCRIBE</a></li></ul></blockquote><p>举个例子：</p><p><strong>连接A</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE speaker</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"speaker"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>订阅了一个speaker的channel，我们在另外一个端口中发布消息看看：</p><p><strong>连接B</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH speaker <span class="string">"hello world!"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p><strong>连接A</strong>立即收到消息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"speaker"</span></span><br><span class="line">3) <span class="string">"hello world!"</span></span><br></pre></td></tr></table></figure><h2 id="推送消息的格式化"><a href="#推送消息的格式化" class="headerlink" title="推送消息的格式化"></a>推送消息的格式化</h2><p>Redis中的一条消息是一个<a href="https://diiyw.com/2019/09/19/redis-proto/">数组类型</a>。</p><ul><li>订阅时</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE speaker</span><br></pre></td></tr></table></figure><p>实际发送了指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n<span class="variable">$9</span>\r\nsubscribe\r\n<span class="variable">$7</span>\r\nspeaker\r\n:1</span><br></pre></td></tr></table></figure><p><code>*3</code>数组的长度为3，<code>$9</code>,<code>$7</code>表示接下来的数组元素的长度,<code>:1</code>表示此次订阅了1个channel。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Message System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用管道加速redis的查询</title>
      <link href="/2020/03/28/using-piplining-to-speedup-redis-queries/"/>
      <url>/2020/03/28/using-piplining-to-speedup-redis-queries/</url>
      
        <content type="html"><![CDATA[<h2 id="请求-响应模型和RTT"><a href="#请求-响应模型和RTT" class="headerlink" title="请求/响应模型和RTT"></a>请求/响应模型和RTT</h2><p>Redis的TCP的服务采用Client/Server模型。意味着一次查询将遵循以下步骤：</p><ul><li>客户端发起请求阻塞直到服务器响应。</li><li>服务器会处理请求操作的命令，并返回结果。</li></ul><p>例如下面的四次的命令执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr x</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr x</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; incr x</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; incr x</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><p>客户端和服务端的通讯是建立在网络之上，如果是回环链路（本地网络）将是非常快的，相反互联网之上将相对较慢。但是无论在哪种网络下，数据包从客服端到服务端，再由服务端返回到客户端并接收的一个周期我们叫做RTT(Round Trip Time)，这样我们可以参考RTT时间来优化性能（比如插入大量的元素，或者添加大量的数据库键值）在回环链路的RTT是非常短的(ping 127.0.0.1 可以看到结果)，但是我们写入大量数据时，性能依旧是个问题。</p><a id="more"></a><h2 id="Redis-管道"><a href="#Redis-管道" class="headerlink" title="Redis 管道"></a>Redis 管道</h2><p>Redis 管道的就是将多次需要执行的指令合并成一次传输，服务端会一次返回每个指令的结果。如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (<span class="built_in">printf</span> <span class="string">"PING\r\nPING\r\nPING\r\n"</span>; sleep 1) | nc localhost 6379</span></span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br></pre></td></tr></table></figure><p>回到上面的例子，使用管道进行发送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (<span class="built_in">printf</span> <span class="string">"incr x\r\nincr x\r\nincr x\r\n"</span>; sleep 1) | redis-cli --pipe</span></span><br><span class="line">All data transferred. Waiting for the last reply...</span><br><span class="line">Last reply received from server.</span><br><span class="line">errors: 0, replies: 3</span><br></pre></td></tr></table></figure><p><strong>特别注意：</strong> 如果客户端通过管道发送大量的命令，服务端将会使用内存队列缓存每个命令结果。所以在发送时需要控制命令的数量。</p><h2 id="不只是RTT的问题"><a href="#不只是RTT的问题" class="headerlink" title="不只是RTT的问题"></a>不只是RTT的问题</h2><p>使用管道是可以上少网络请求，从而减少RTT耗时。实际上除了网络层上面的时间消耗，使用非管道进行操作时，redis需要频繁的进行Socket I/O的read()和write() 频繁的上下文切换，是一笔巨大的开销。如果使用了管道，只需要一次的read(),，同理write()也只需一次系统调用，极大的减少了开销。这样每秒执行的总查询数，从最初几乎呈线性增加，最终达到不使用管道方法基准的10倍，</p><p><img alt="xdebug-listening" data-src="/images/pipeline_iops.png"></p><p>但是实际测试中却达到了惊人的400倍？基于Go语言的测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis server版本为5.0.4 On Mac OS X</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">pipelining()</span><br><span class="line">fmt.Printf(<span class="string">"with pipelining: %s\n"</span>, time.Now().Sub(start))</span><br><span class="line">start = time.Now()</span><br><span class="line">withoutPipelining()</span><br><span class="line">fmt.Printf(<span class="string">"without pipelining: %s\n"</span>, time.Now().Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withoutPipelining</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp4"</span>, <span class="string">"127.0.0.1:6379"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">_, _ = conn.Write([]<span class="keyword">byte</span>(<span class="string">"PING\r\n"</span>))</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">7</span>)</span><br><span class="line">_, _ = conn.Read(b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pipelining</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp4"</span>, <span class="string">"127.0.0.1:6379"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">var</span> pings strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">pings.WriteString(<span class="string">"PING\r\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">_, _ = conn.Write([]<span class="keyword">byte</span>(pings.String()))</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">7000</span>)</span><br><span class="line">_, _ = conn.Read(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with pipelining: <span class="number">20.74797</span>ms</span><br><span class="line">without pipelining: <span class="number">8.502332207</span>s</span><br></pre></td></tr></table></figure><h2 id="管道和脚本对比"><a href="#管道和脚本对比" class="headerlink" title="管道和脚本对比"></a>管道和脚本对比</h2><p>Redis在2.6之后的版本中支持脚本。管道的一些例子可以直接转换到脚本方式更高的效率执行。特别是需要在服务端进行大量计算时，脚本可以最小延迟的执行，使得读取，计算，写入等操作变的非常快。</p><h2 id="扩展：为什么在本地回环链路上循环执行操作还是很慢？"><a href="#扩展：为什么在本地回环链路上循环执行操作还是很慢？" class="headerlink" title="扩展：为什么在本地回环链路上循环执行操作还是很慢？"></a>扩展：为什么在本地回环链路上循环执行操作还是很慢？</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"><span class="keyword">FOR</span>-ONE-SECOND:</span><br><span class="line">    Redis.SET(<span class="string">"foo"</span>,<span class="string">"bar"</span>)</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>这段代码不停的进行<code>SET</code>操作，本地回环链路中，都是在同一台机子测试时，只有内存的数据拷贝，实际上应该是不会有额外的损耗的？但是却却相反，依然很慢。这是为什么呢？真实原因是系统不是一直都运行某个程序的,任何程序都是在系统的内核调度下运行，所以频繁<code>SET</code>系统要进行频繁的调度才能最终完成任务，本质上还是操作太多的IO操作，才导致性能下降。这就是为什么本地环境下测试依然很慢的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x509 certificate is valid</title>
      <link href="/2020/02/24/x509-certificate-is-valid/"/>
      <url>/2020/02/24/x509-certificate-is-valid/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Go在拉取包的报了这一个错误：</p><p><code>x509: certificate is valid for gomirrors.org, www.gomirrors.org, not goproxy.io</code></p><p>goproxy.io是Go的模块代理服务。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>出现这种情况基本是受到了中间人攻击，所谓中间人攻击就是你的电脑网络请求被监控。</p><p>一般出现在公司电脑上，或者你开启了网络请求的拦截，比如抓包工具Charles。我们把它关闭就正常了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql的事务隔离级别</title>
      <link href="/2019/10/31/mysql-transaction-isolation/"/>
      <url>/2019/10/31/mysql-transaction-isolation/</url>
      
        <content type="html"><![CDATA[<p>Mysql 有四种事务隔离级别</p><table><thead><tr><th>隔离级别</th><th>脏读（Dirty Read）</th><th>不可重复读（NonRepeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>读未提交（Read uncommitted）</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交（Read committed</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读（Repeatable read）</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化（Serializable ）</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><ul><li><p><strong>脏读</strong> 一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，读取到了不想得到的数据了。</p></li><li><p><strong>幻读</strong> 第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p></li><li><p><strong>不可重复读</strong> 数据库访问中，在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p></li></ul><a id="more"></a><p>InnoDB默认是可重复读的（REPEATABLE READ），查询当前使用的隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p><code>test</code>数据库测试新建一张表<code>person</code>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `person` (</span><br><span class="line">  `id` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `city` varchar(255) DEFAULT NULL,</span><br><span class="line">  `age` mediumint(9) DEFAULT NULL,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>我们开启两个客服端A、B备用</p><p><code>A</code> 开启事务插入一条数据，不需要提交事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into person (city)values(&apos;china&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  1 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B</code> 中并不会查询到A中事务提交的数据，不会出现脏读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from person;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B</code>客户端更改为<code>读未提交</code>（Read Uncommitted）那么就能读取到A事务中插入的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  1 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查询<code>A</code>中隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@session.tx_isolation;</span><br><span class="line">+------------------------+</span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+------------------------+</span><br><span class="line">| REPEATABLE-READ        |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>虽然<code>A</code>中的隔离级别是<code>Repeatable read</code>但是<code>B</code>指定<code>Read Uncommitted</code>级别照样读取到了其中的事务数据。</p><p>到此<code>A</code>的隔离级别为<code>Repeatable read</code>,修改<code>B</code>的隔离级别为<code>Read committed</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read committed;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="不可重复度"><a href="#不可重复度" class="headerlink" title="不可重复度"></a>不可重复度</h2><p>之前的例子中手动回滚了事务，此时person表是空的。我们<code>A</code>和<code>B</code>都开启一个事务，A中提交事务，观察<code>B</code>查询数据。</p><p><code>B</code> 开启事务查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from person;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>A</code>开启事务插入一条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into person (city)values(&apos;china&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B</code>事务中查询记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  2 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p><code>B</code>事务中两次查询到数据不一致。不可重复读就是事务中数据不能进行重复读取，不然会导致数据不一致。</p><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p>同上面操作我们修改<code>B</code>的隔离级别为<code>Repeatable read</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level repeatable read</span><br></pre></td></tr></table></figure><p>此时<code>A</code>和<code>B</code>的隔离级别是一致的，重复上面的操作</p><p><code>B</code> 开启事务查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  2 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>A</code>开启事务插入一条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into person (city)values(&apos;china&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B</code>事务中查询记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  2 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B</code>事务中两次查询到数据是一致的。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p><code>A</code> 和<code>B</code>事务中进行操作，步骤接替进行看效果</p><p><code>A</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>A</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  2 | china | NULL | NULL |</span><br><span class="line">|  3 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p><code>B</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  2 | china | NULL | NULL |</span><br><span class="line">|  3 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>A</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into person (id,city)values(1,&apos;xm&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  2 | china | NULL | NULL |</span><br><span class="line">|  3 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>A</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  2 | china | NULL | NULL |</span><br><span class="line">|  3 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>A</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from person;</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">| id | city  | age  | name |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  1 | xm    | NULL | NULL |</span><br><span class="line">|  2 | china | NULL | NULL |</span><br><span class="line">|  3 | china | NULL | NULL |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into person(id,city)values(1,&quot;xm2&quot;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;</span><br></pre></td></tr></table></figure><p>仔细对比可以发现，即使<code>A</code>中提交了新数据，但是<code>B</code>中并不会找到新增加的数据，所以天真的以为可以添加一条新数据，这时候mysql报出来主键重复了，就像是产生幻觉一样。</p><p>在<code>B</code>查询语句可以知道数据库只有两条记录，如果我们在B中更新记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update person set city=&apos;b&apos;;</span><br><span class="line">Query OK, 3 rows affected (0.01 sec)</span><br><span class="line">Rows matched: 3  Changed: 3  Warnings: 0</span><br></pre></td></tr></table></figure><p>咦！怎么有三条记录更新，不是两条吗。这同样产生了幻觉。</p><p>*<em>注意 *</em>当隔离级别是可重复读，且禁用<code>innodb_locks_unsafe_for_binlog</code>的情况下，在搜索和扫描<code>index</code>的时候使用的<code>next-key locks</code>可以避免幻读。</p><p>当然如果使用update语句，mysql会加锁会保证数据一致。</p><p><code>A</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update person set city=&apos;a&apos; where id=1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure><p><code>B</code>等待<code>A</code>释放锁或者超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update person set city=&apos;b&apos; where id=1;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go中的堆栈与逃逸分析</title>
      <link href="/2019/10/28/go-stack-heap-and-escape/"/>
      <url>/2019/10/28/go-stack-heap-and-escape/</url>
      
        <content type="html"><![CDATA[<p>Go的变量到底是分配在堆还是栈，我们先聊下下概念。</p><ul><li><strong>堆(heap)</strong> 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</li><li><strong>栈 (stack)</strong> 由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。Go在分配栈的时候，预先分配2k的空间。</li></ul><p>理论上分配在栈上的数据操作速度快与堆上。堆上使用的内存需要垃圾回收(GC),栈上的内存是自动释放的且是明确不共享的。</p><a id="more"></a><p>先看个例子 <code>escape.go</code> :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">newUser()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUser</span><span class="params">()</span> <span class="title">user</span></span> &#123;</span><br><span class="line">u := user&#123;</span><br><span class="line">name:  <span class="string">"tom"</span>,</span><br><span class="line">email: <span class="string">"tom@x.com"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ go tool compile -m escape.go</span><br><span class="line">escape.go:8:6: can inline main</span><br></pre></td></tr></table></figure><p>这里只说明main可以内联，此时u是分配到栈上的，因为没有其他程序共享<code>u</code>变量。继续修改下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">newUser()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUser</span><span class="params">()</span> *<span class="title">user</span></span> &#123;</span><br><span class="line">u := user&#123;</span><br><span class="line">name:  <span class="string">"tom"</span>,</span><br><span class="line">email: <span class="string">"tom@x.com"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ go tool compile -m escape.go</span><br><span class="line">escape.go:8:6: can inline main</span><br><span class="line">escape.go:18:6: can inline changeName</span><br><span class="line">escape.go:18:17: moved to heap: u</span><br></pre></td></tr></table></figure><p>我们返回user的指针，Go判断这段内存需要被共享于是本身<code>u</code>在堆上的被移动到了栈了。如果我们修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUser</span><span class="params">()</span> *<span class="title">user</span></span> &#123;</span><br><span class="line">u := &amp;user&#123;</span><br><span class="line">name:  <span class="string">"tom"</span>,</span><br><span class="line">email: <span class="string">"tom@x.com"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ go tool compile -m escape.go</span><br><span class="line">escape.go:8:6: can inline main</span><br><span class="line">escape.go:17:10: &amp;user literal escapes to heap</span><br></pre></td></tr></table></figure><p>Go直接将这段内存分配到堆上了。一旦分配在堆上就要进行垃圾回收处理了。这里要注意的每个Goroutine都有自己的栈内存互不影响，Goroutine之间栈内存能不能共享！</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言Channel的Buffered与Unbuffered</title>
      <link href="/2019/10/24/go-channel-buffer/"/>
      <url>/2019/10/24/go-channel-buffer/</url>
      
        <content type="html"><![CDATA[<p>Go语言channel在应用中相当的常见了，其中channel分两类，一种是 buffered channel，另一种是 unbuffered channel。</p><a id="more"></a><h2 id="Unbuffered-Channel"><a href="#Unbuffered-Channel" class="headerlink" title="Unbuffered Channel"></a>Unbuffered Channel</h2><p>没缓冲的channel，我们看个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Goroutine."</span>)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不休眠一秒是看不到输出的。这里我们设置的Timeout是1秒，我们默认了这个Goroutine不会执行耗时任务，假如执行时间未知，此方法就行不通。可以引入channel解决这个问题，请看示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">end := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">"Goroutine."</span>)</span><br><span class="line">end &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>end</code>是一个Unbuffered channel，无论Goroutine执行多久结束，主线程都会等待其完全执行完成，从这里看出来</p><p>Unbuffered channel是可以用来做同步的，相反的Buffered channel可以做异步。上面的例子可以做一些变化，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">end := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">"Goroutine."</span>)</span><br><span class="line">&lt;-end</span><br><span class="line">&#125;()</span><br><span class="line">end &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种结果是一样的。只是方式上存在差异，前者读阻塞，后者写阻塞。</p><h2 id="Buffered-Channel"><a href="#Buffered-Channel" class="headerlink" title="Buffered Channel"></a>Buffered Channel</h2><p>上面的例子改成带缓冲的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">end := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">"Goroutine."</span>)</span><br><span class="line">&lt;-end</span><br><span class="line">&#125;()</span><br><span class="line">end &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序不会有任何输出，此时的<code>end</code>是带缓冲的，没等Goroutine执行，<code>end</code>就写入<code>true</code>主程就退出了。但是我们换一种方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">end := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">"Goroutine."</span>)</span><br><span class="line">end &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时是可以输出的。虽然我们设置缓冲，但是<code>&lt;-end</code>是读阻塞的，因为此时<code>end</code>并没有值。所以Buffered Channel也是可以做同步的，只是应用在多个Goroutine。但是不建议这样做，如果不小心对channel操作就会造成意想不到的一些BUG，此时应该考虑使用context包进行上下文管理。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Module使用教程</title>
      <link href="/2019/10/15/go-moudle-using/"/>
      <url>/2019/10/15/go-moudle-using/</url>
      
        <content type="html"><![CDATA[<p>Go从<code>1.11</code>版本开始内置包管理工具，直到<code>1.14</code>已经正式支持Go Mdoule。以最新版Go1.13为例，学习GO包管。</p><a id="more"></a><h2 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h2><p>配置环境变量<code>GO111MODULE</code>，默认是auto，如果目录中包含go.mod将使用go modules模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>显示命令行帮助</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod</span><br></pre></td></tr></table></figure><p>进入到项目目录初始化模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init &#123;moudle-name&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意，你的包名需要与被引入使用的包名一致否则无法匹配，Go将无法编译应用。例如：你将包放到了<code>github.com/xx/package</code> 如果这里指定了<code>{moudle-name}</code>为<code>package</code>，那么别人引用此包，将报错无法继续。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>执行该条命令就开始自动下载安装第三方包了，同时如果有包不在使用，将会从<code>go.mod</code>中移除。执行<code>go build</code> 也会自动安装依赖，是不是很方便。</p><h2 id="go-mod文件说明"><a href="#go-mod文件说明" class="headerlink" title="go.mod文件说明"></a>go.mod文件说明</h2><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module github.com/micro/go-micro</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/BurntSushi/toml v0.3.1</span><br><span class="line">github.com/beevik/ntp v0.2.0</span><br><span class="line">github.com/bitly/go-simplejson v0.5.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>很直观的就可以看的出来<code>require</code>就是引用的包格式是 “包名+版本”这的<code>版本</code>其实就是tag，如果没有tag就会拉取master分支，会是下面的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golang.org/x/net v0.0.0-20191014212845-da9a3fd4c582</span><br></pre></td></tr></table></figure><p><code>20191014212845</code>是commit的提交时间，<code>da9a3fd4c582</code>就是此次的commit的哈希。使用<code>go get</code>时我们可以指定版本或者分支如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get gitlab.com/xxx/xx@cheuk-go</span><br><span class="line">go get gitlab.com/xxx/xx@v1.0.2</span><br></pre></td></tr></table></figure><p>如果是手动写入go.mod需要将<code>@</code>替换成空格，这样就可以正常拉取。</p><h2 id="包映射"><a href="#包映射" class="headerlink" title="包映射"></a>包映射</h2><p>除了require方式，我们还可以指定require的包使用本地指定的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace github.com/BurntSushi/toml v0.3.1 =&gt; ./toml</span><br></pre></td></tr></table></figure><p>包<code>github.com/BurntSushi/toml</code>现在引用了一个我们放在本地的一个目录<code>toml</code></p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>现在Go第三方有提供了代理，目前有三个</p><ul><li><a href="https://goproxy.cn" target="_blank" rel="noopener">https://goproxy.cn</a></li><li><a href="https://goproxy.io" target="_blank" rel="noopener">https://goproxy.io</a></li><li><a href="https://mirrors.aliyun.com/goproxy/" target="_blank" rel="noopener">https://mirrors.aliyun.com/goproxy/</a></li></ul><p>设置环境变量<code>GOPROXY</code>，<code>direct</code>表示在出错的时候使用直连。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><h2 id="私有包"><a href="#私有包" class="headerlink" title="私有包"></a>私有包</h2><p>我们开发不可能所有包来自<code>github</code>，大部分公司都自建了<code>gitlab</code>服务。需要进行以下两部操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global url.<span class="string">"git@gitlab.xxx.com:"</span>.insteadOf <span class="string">"http://gitlab.xxx.com/"</span></span><br></pre></td></tr></table></figure><p>这里将http替换成ssh可以进行免密拉取包。如果我们设置了代理，我们配置<code>GOPRIVATE</code>让其不走代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPRIVATE=*.xxx.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP的XDebug调试工具安装</title>
      <link href="/2019/10/10/php-xdebug-install/"/>
      <url>/2019/10/10/php-xdebug-install/</url>
      
        <content type="html"><![CDATA[<p>XDebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况，极其方便。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>最简单的安装方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pecl install xdebug</span><br></pre></td></tr></table></figure><p>这种方式安装后，php.ini自动添加启用扩展。</p><p>可用通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -m |grep xdebug</span><br></pre></td></tr></table></figure><p>查询是否安装好可扩展。</p><p>详情可以参考<a href="https://xdebug.org/docs/install" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开<code>php.ini</code>编辑，如果不知道<code>php.ini</code>在自己电脑哪个位置的，可以执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ php --ini</span><br><span class="line">Configuration File (php.ini) Path: /usr/<span class="built_in">local</span>/etc/php/7.3</span><br><span class="line">Loaded Configuration File:         /usr/<span class="built_in">local</span>/etc/php/7.3/php.ini</span><br><span class="line">Scan <span class="keyword">for</span> additional .ini files <span class="keyword">in</span>: /usr/<span class="built_in">local</span>/etc/php/7.3/conf.d</span><br><span class="line">Additional .ini files parsed:      /usr/<span class="built_in">local</span>/etc/php/7.3/conf.d/ext-opcache.ini</span><br></pre></td></tr></table></figure><p>可以看到<code>php.ini</code>的文件全路径了。</p><p>将下面的配置，添加到<code>php.ini</code>最后</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;开启远程调试</span></span><br><span class="line"><span class="section">[XDebug]</span></span><br><span class="line"><span class="attr">xdebug.remote_enable</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.profiler_enable</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.remote_host</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">xdebug.profiler_enable_trigger</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.profiler_output_name</span> = cachegrind.out.%t.%p</span><br><span class="line"><span class="attr">xdebug.profiler_output_dir</span> = <span class="string">"~/phpxdebug"</span></span><br><span class="line"><span class="attr">xdebug.remote_autostart</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.auto_trace</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">xdebug.show_local_vars</span>=<span class="number">0</span></span><br><span class="line"><span class="comment">;远程处理协议</span></span><br><span class="line"><span class="attr">xdebug.remote_handel</span>=dbgp</span><br><span class="line"><span class="comment">;端口号</span></span><br><span class="line"><span class="attr">xdebug.remote_port</span>=<span class="number">9001</span></span><br><span class="line"><span class="comment">;IDE KEY</span></span><br><span class="line"><span class="attr">xdebug.idekey</span>=<span class="string">"phpxdebug"</span></span><br></pre></td></tr></table></figure><p>如果配置了<code>php</code>服务则重启下<code>php</code>服务。</p><h2 id="IDE配置"><a href="#IDE配置" class="headerlink" title="IDE配置"></a>IDE配置</h2><p>以idea为例，修改下图的配置,端口需改为我们配置的<code>9001</code></p><p><img alt="xdebug-port" data-src="/images/xdebug-port.jpg"></p><p><img alt="xdebug-ide-setting" data-src="/images/xdebug-ide-setting.jpg"></p><p>记得点击，开始监听调试，图示表示已经在监听。</p><p><img alt="xdebug-listening" data-src="/images/xdebug-listening.jpg"></p><p>创建文件验证一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$q = <span class="keyword">new</span> \stdClass();</span><br><span class="line"></span><br><span class="line">$q-&gt;name = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">$b = [<span class="string">"age"</span> =&gt; <span class="number">13</span>];</span><br><span class="line"></span><br><span class="line">var_dump((object)array_merge((<span class="keyword">array</span>)$q, $b));</span><br></pre></td></tr></table></figure><p>在第7行打一个断点。</p><p><img alt="xdebug-dd" data-src="/images/xdebug-dd.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php index.php</span><br></pre></td></tr></table></figure><p>如果IDE弹出Debug窗口，那么xdebug我们已经配置成功，尽情玩耍吧。如图所示</p><p><img alt="xdebug-ide-window" data-src="/images/xdebug-ide-window.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> XDebug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Docker中调试Go程序</title>
      <link href="/2019/09/29/go-docker-debug/"/>
      <url>/2019/09/29/go-docker-debug/</url>
      
        <content type="html"><![CDATA[<p>我们已经构建一个用于编译Go程序的，如果我们使用Mac和Windows开发go，又该如在docker中调试我们程序。这其中用到了一个调试工具delve的远程调试功能。</p><a id="more"></a><h2 id="认识Delve"><a href="#认识Delve" class="headerlink" title="认识Delve"></a>认识Delve</h2><p>项目地址：<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">https://github.com/go-delve/delve</a></p><p>Devle是一个非常棒的golang 调试工具，支持多种调试方式，直接运行调试，或者attach到一个正在运行中的Go程序，进行调试。线上Go服务出现问题时，Devle是必不可少的在线调试工具，如果使用docker，也可以把Devle打进docker镜像里，从而调试代码。</p><h2 id="创建调试容器"><a href="#创建调试容器" class="headerlink" title="创建调试容器"></a>创建调试容器</h2><p>Dockerfile内容如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最新版本构建容器</span></span><br><span class="line"><span class="keyword">FROM</span> golang:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> cheuk</span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /godebuger</span></span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /godebuger</span></span><br><span class="line"><span class="comment"># delve的调试端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">2345</span></span><br><span class="line"><span class="comment"># 环境变量配置</span></span><br><span class="line"><span class="keyword">ENV</span> GOPATH $GOPATH:/godebuger</span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE on</span><br><span class="line"><span class="comment"># 开下梯子</span></span><br><span class="line"><span class="keyword">ENV</span> GOPROXY <span class="string">"https://goproxy.cn"</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go get -u github.com/go-delve/delve/cmd/dlv</span></span><br><span class="line"><span class="comment"># 磁盘映射package</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/godebuger"</span>,<span class="string">"/go/src"</span>]</span></span><br></pre></td></tr></table></figure><p>构建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t godebuger .</span><br></pre></td></tr></table></figure><p>选择一个项目，并映射到进入容器中，<code>$(pwd)</code>就是项目的目录，我习惯进入项目目录执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -v $GOPATH/src:/go/src -v $(pwd):$(pwd) godebuger</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这里<code>$(pwd):$(pwd)</code>是将项目完整目录映射到容器，不然在IDE下无法进行打断点调试。</p><p>如果我们还使用GOPATH模式编译程序那么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=off</span><br></pre></td></tr></table></figure><p>进入到项目目录编译，开始调试程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags <span class="string">"all=-N -l"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv --listen=:2345 --headless=<span class="literal">true</span> --api-version=2 --accept-multiclient <span class="built_in">exec</span> ./godebuger</span><br></pre></td></tr></table></figure><p>这里的<code>godebuger</code>是项目编译后的程序名称。</p><p>这里每一步操作都很麻烦，我们写个脚本放到<code>$GOPATH/bin</code>。如果已经使用go mod 模式则需要去掉<code>-e GO111MODULE=off</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run --rm -it \</span><br><span class="line">-v <span class="variable">$GOPATH</span>/src:/go/src \</span><br><span class="line">-v $(<span class="built_in">pwd</span>):$(<span class="built_in">pwd</span>) \</span><br><span class="line">-e GO111MODULE=off \</span><br><span class="line">-p 2345:2345 \</span><br><span class="line">godebuger /bin/sh -c <span class="string">'cd '</span><span class="string">"<span class="variable">$(pwd)</span>"</span><span class="string">' &amp;&amp; go build -gcflags "all=-N -l" -o godebuger &amp;&amp; dlv --listen=:2345 --headless=true --api-version=2 --accept-multiclient exec ./godebuger'</span></span><br></pre></td></tr></table></figure><p>在项目目录执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ godebuger</span><br><span class="line">API server listening at: [::]:2345</span><br></pre></td></tr></table></figure><p>即可开启调试。如果是<code>*nix</code>系统，添加下执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x <span class="variable">$GOPATH</span>/bin/godebuger</span><br></pre></td></tr></table></figure><h2 id="IDE配置"><a href="#IDE配置" class="headerlink" title="IDE配置"></a>IDE配置</h2><p>使用idea为例，点击编辑配置项</p><p><img alt data-src="/images/godebuger-idea.jpg"></p><p>添加go远程调试项，修改名称点OK创建</p><p><img alt="godebuger-idea-add-remote" data-src="/images/godebuger-idea-add-remote.jpg"></p><p>点击如图所示的按钮，即可正常调试Go程序</p><p><img alt="godebuger-start-debug" data-src="/images/godebuger-start-debug.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go1.5至Go1.14的版本更新史</title>
      <link href="/2019/09/29/go-version-diff/"/>
      <url>/2019/09/29/go-version-diff/</url>
      
        <content type="html"><![CDATA[<p>我们现在使用的是Go 1.7.6版本。至于为什么从1.5开始总结，这是一个很重要的版本，实现方面有很多变化。最重要的是实现了自举。本文列出一些重大变化以及对我们升级有用的信息。</p><a id="more"></a><h2 id="Go-1-5"><a href="#Go-1-5" class="headerlink" title="Go 1.5"></a>Go 1.5</h2><p>该版本主要变化有以下几点</p><ul><li>实现自举，使用少量汇编，用GO写GO。实现自举的目的是为了能更好的对GC管理优化</li><li>引入并发垃圾回收器，大幅降低GC延迟（Stop The World）</li><li>默认情况下，Go 程序运行时的 GOMAXPROCS 会被设置为可用的核数，之前默认为 1。再也<strong>不用手动去设置</strong>了</li></ul><h3 id="Map-literals"><a href="#Map-literals" class="headerlink" title="Map literals"></a>Map literals</h3><p>Go1.4之前我们需要这样写代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> i32 <span class="keyword">struct</span> &#123;</span><br><span class="line">  value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = []i32&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="keyword">map</span>[i32]<span class="keyword">string</span>&#123;</span><br><span class="line">        i32&#123;<span class="number">3</span>&#125;:<span class="string">"i32=3"</span>,</span><br><span class="line">        i32&#123;<span class="number">4</span>&#125;:<span class="string">"i32=4"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i,m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对于<code>i32</code>类型来说，在初始化一个切片时，无需显式的带上元素类型名称<code>i32</code>，即</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = []i32&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>而不是需要传入名称：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = []i32&#123;i32&#123;<span class="number">1</span>&#125;, i32&#123;<span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>但是当<code>i32</code>作为map类型的key时，初始化map时则需要带上元素类型<code>i32</code>。在Go 1.5版本修复了。也就是说，下面的代码在Go 1.5以及之后版本中可以顺利编译通过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = []i32&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="keyword">map</span>[i32]<span class="keyword">string</span>&#123;</span><br><span class="line">        &#123;<span class="number">3</span>&#125;:<span class="string">"i32=3"</span>,</span><br><span class="line">        &#123;<span class="number">4</span>&#125;:<span class="string">"i32=4"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i,m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GO-1-6"><a href="#GO-1-6" class="headerlink" title="GO 1.6"></a>GO 1.6</h2><p>该版本主要对GO的生态进行了调整</p><ul><li>添加<code>linux/mips64</code>，<code>linux/mips64le</code>，<code>android/386</code>平台的实验性支持。</li><li>go tool工具链调整，对位于我们升级意义不大。</li><li>运行时和大面积的标准库BUG修复和调整。</li></ul><h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>现在如果我们并发的map进行操作，GO会检测并抛出错误。Go 1.6之前版本，一旦程序以panic方式退出，runtime便会将所有goroutine的stack信息打印出来，现在只会打印正在running的goroutine的stack信息。</p><h3 id="核心库和标准包"><a href="#核心库和标准包" class="headerlink" title="核心库和标准包"></a>核心库和标准包</h3><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>Go 1.6已经标准库中已经支持HTTP/2。并且当使用<code>https</code>时，client和server端将自动默认使用HTTP/2协议。</p><h4 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h4><p>Go templates的空白字符包括：空格、水平tab、回车和换行符。Go 1.6提供了来帮助大家去除action前后的空白字符。示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"text/template"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t = template.Must(template.New(<span class="string">"tmpl"</span>).Parse(<span class="string">`</span></span><br><span class="line"><span class="string">    &#123;&#123;"hello" -&#125;&#125;</span></span><br><span class="line"><span class="string">   &lt;br&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;- "world"&#125;&#125;</span></span><br><span class="line"><span class="string">    `</span>))</span><br><span class="line"></span><br><span class="line">err := t.Execute(os.Stdout, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"executing template:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<code>hello&lt;br&gt;world</code>，<code>&lt;br&gt;</code>左右的空白将会被清除。</p><h4 id="Tls"><a href="#Tls" class="headerlink" title="Tls"></a>Tls</h4><p><code>crypto/tls</code> 包现在如果没有指定证书也可以监听。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/tls"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> config = &amp;tls.Config&#123;</span><br><span class="line">GetCertificate: <span class="function"><span class="keyword">func</span><span class="params">(info *tls.ClientHelloInfo)</span> <span class="params">(certificate *tls.Certificate, e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">_, err := tls.Listen(<span class="string">"tcp4"</span>, <span class="string">":2020"</span>, config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-1-7"><a href="#Go-1-7" class="headerlink" title="Go 1.7"></a>Go 1.7</h2><p>该版本的主要是对性能的影响</p><ul><li>实验性的支持<code>linux/s390x</code>，<code>plan9/arm</code></li><li>编译性能提升，编译出的文件变小</li><li>运行时和标准库BUG修复和调整</li></ul><h3 id="HTTP-Tracing"><a href="#HTTP-Tracing" class="headerlink" title="HTTP Tracing"></a>HTTP Tracing</h3><p>引用<code>net/http/httptrace</code>包对http请求进行追踪测试</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>包<code>testing</code>现在支持子测试（subtest），更好的支持表驱动测试和更细的粒度测试。</p><p><strong>表格驱动测试</strong>：有时也被归为关键字驱动测试(keyword-driven testing，是针对自动化测试的软件测试方法，它将创建测试程序的步骤分为规划及实现二个阶段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEq</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s2 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k1, v1 := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">v2 := s2[k1]</span><br><span class="line"><span class="keyword">if</span> v1 != v2 &#123;</span><br><span class="line">t.Errorf(<span class="string">"s1:%d != s2:%d"</span>, v1, v2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平常我们是使用此方法测试，<code>s1</code>是我们期望的结果，我们改造一下使用subtest</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sub_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEq</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s2 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k1, v1 := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">v2 := s2[k1]</span><br><span class="line">t.Run(<span class="string">"index 0"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> k1 != <span class="number">0</span> &#123;</span><br><span class="line">t.Skip(k1)</span><br><span class="line">&#125;</span><br><span class="line">assertEq(v1, v2, t)</span><br><span class="line">&#125;)</span><br><span class="line">t.Run(<span class="string">"index 1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> k1 != <span class="number">1</span> &#123;</span><br><span class="line">t.Skip(k1)</span><br><span class="line">&#125;</span><br><span class="line">assertEq(v1, v2, t)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertEq</span><span class="params">(v1, v2 <span class="keyword">int</span>, t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> v1 != v2 &#123;</span><br><span class="line">t.Errorf(<span class="string">"got %d; want %d"</span>, v2, v1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestEq/index_1#01</span><br><span class="line">    --- FAIL: TestEq/index_1#01 (0.00s)</span><br><span class="line">        sub_test.go:27: got 4; want 2</span><br></pre></td></tr></table></figure><p>测试结果中<code>index_1</code>是我们子测试的名称，这样我们可很清楚的知道那部分测试是有问题的。</p><h3 id="核心标准库"><a href="#核心标准库" class="headerlink" title="核心标准库"></a>核心标准库</h3><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Go 1.7 已经将context上下文包引入到标准库中，可以直接import，轻松进行<strong>并发控制</strong>，<strong>平滑退出</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">"监控超时退出:"</span>, ctx.Err())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"正在监控Goroutine"</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ctx)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在监控Goroutine</span><br><span class="line">正在监控Goroutine</span><br><span class="line">正在监控Goroutine</span><br><span class="line">监控超时退出: context deadline exceeded</span><br></pre></td></tr></table></figure><h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><p><code>strings</code>的<code>Reader</code> 的 <code>Read</code>方法如果没有数据将会返回长度0和<code>io.EOF</code> 之前的版本不会产生错误！</p><h4 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h4><p>time.Duration 如果0时段，现在<code>time.Duration.String</code>是<code>0s</code>而不是<code>0</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(time.Duration(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-1-8"><a href="#Go-1-8" class="headerlink" title="Go 1.8"></a>Go 1.8</h2><p>此版本调整的地方</p><ul><li>GC延迟大幅降低，通常是100ms，大部分情况下都是10ms左右</li><li>正式支持<code>linux/mips64</code>，<code>linux/mips64le</code></li><li>移除<code>go tool yacc</code></li><li>编译性能提升15%</li><li>默认安装Go之后 <code>$GOPATH</code> 默认路径为 <code>$HOME/go</code>，如果是Windows则是<code>%USERPROFILE%/go</code></li><li>Plugin的初步支持</li></ul><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>1.8 开始，tag不一样的struct可以执行显性转化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">Value <span class="keyword">int</span> <span class="string">`json:"value"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">Value <span class="keyword">int</span> <span class="string">`json:"b_value"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = &amp;A&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = (*B)(a)</span><br><span class="line"></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心和标准库"><a href="#核心和标准库" class="headerlink" title="核心和标准库"></a>核心和标准库</h3><h4 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h4><p>1.8 之前版本，我们对自定义的slice排序需要实现sort.Inteface接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Score <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Inteface接口</span></span><br><span class="line"><span class="keyword">type</span> Person []Student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i].Score &lt; p[j].Score &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> students = Person&#123;&#123;<span class="number">90</span>&#125;,&#123;<span class="number">83</span>&#125;,&#123;<span class="number">87</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">sort.Sort(students)</span><br><span class="line">fmt.Println(students)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.8 之后，我们可以使用更快的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Score <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person []Student</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> students = Person&#123;&#123;<span class="number">90</span>&#125;, &#123;<span class="number">83</span>&#125;, &#123;<span class="number">87</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sort.Slice(students, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> students[i].Score &lt; students[j].Score</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(students)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种结果是一样的，省掉额外代码实现sort.Inteface接口</p><h4 id="HTTP-2-Push"><a href="#HTTP-2-Push" class="headerlink" title="HTTP/2 Push"></a>HTTP/2 Push</h4><p>Go 1.8新增了对<a href="https://en.wikipedia.org/wiki/HTTP/2_Server_Push" target="_blank" rel="noopener">HTTP/2 Push</a>的支持。</p><p><img alt="h2push" data-src="/images/h2push.png"></p><p>简单的介绍下HTTP/2 Push：从图中当Browser向Server发起Get page.html请求后，在同一条TCP Connection上，Server主动将style.css和image.png两个资源文件也推送给了Browser。这是由于Server端启用了HTTP/2 Push机制，并预测判断Browser很可能会在接下来发起Get style.css和image.png两个资源的请求。这些主动推送给Browser的资源很可能是Browser所不需要的或是已经在Browser cache中存在的资源，会造成带宽资源浪费。</p><h4 id="HTTP-Server-优雅退出"><a href="#HTTP-Server-优雅退出" class="headerlink" title="HTTP Server 优雅退出"></a>HTTP Server 优雅退出</h4><p>1.8 新增优雅退出的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Shutdown</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>我们传入一个上下文，当前有未处理完的active connections。将等待处理完，当然我们也不能无限等待下去，我们可以指定上下文的超时时间。</p><h2 id="Go-1-9"><a href="#Go-1-9" class="headerlink" title="Go 1.9"></a>Go 1.9</h2><p>该版本几点变化</p><ul><li>引入类型别名</li><li>并行编译，速度大大提升</li><li><code>./…</code>不再匹配vendor目录</li><li>新增并发map支持<code>sync.Map</code></li></ul><h3 id="语言-1"><a href="#语言-1" class="headerlink" title="语言"></a>语言</h3><p>新的类型别名，类型别名声明方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = B</span><br></pre></td></tr></table></figure><p>type alias并未创造新类型，只是源类型的“别名”，在类型信息上与源类型一致，因此可以直接赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.BValue = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>也可以使用源类型的方法，但是不能定义新方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.Bfunc()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">Afunc</span><span class="params">()</span> // <span class="title">Error</span>: <span class="title">cannot</span> <span class="title">define</span> <span class="title">new</span> <span class="title">methods</span> <span class="title">on</span> <span class="title">non</span>-<span class="title">local</span> <span class="title">type</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><h3 id="核心和标准包"><a href="#核心和标准包" class="headerlink" title="核心和标准包"></a>核心和标准包</h3><h4 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h4><p>新增并发map的支持，<code>sync.Map</code>结构</p><h4 id="Database-sql"><a href="#Database-sql" class="headerlink" title="Database/sql"></a>Database/sql</h4><p>如果<code>Tx.Stmt</code>不可用，将会使用缓存好的<code>Stmt</code>，这样是避免每次重新<code>prepare</code></p><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>Go 1.9提供了高性能<code>math/bits</code> 应对bit位的操作这个问题。</p><h2 id="Go-1-10"><a href="#Go-1-10" class="headerlink" title="Go 1.10"></a>Go 1.10</h2><p>该版本变化不大，几点特色：</p><ul><li>默认的GOROOT，开发者无需显式设置GOROOT环境变量，go程序会自动根据自己所在路径推导出GOROOT的路径。</li><li>通过cache实现增量构建</li><li>新的环境变量<code>GOTMPDIR</code></li><li>test的文件没有变化，那么test的结果会被缓存</li></ul><h3 id="核心和标准包-1"><a href="#核心和标准包-1" class="headerlink" title="核心和标准包"></a>核心和标准包</h3><h4 id="Strings-1"><a href="#Strings-1" class="headerlink" title="Strings"></a>Strings</h4><p>该包中添加了一个<code>Builder</code>类型，可以用来字符串拼接。降低字符串的拼接的拷贝带来的内存分配和释放的性能损失。</p><h2 id="Go-1-11"><a href="#Go-1-11" class="headerlink" title="Go 1.11"></a>Go 1.11</h2><p>该版本添加了WebAssembly的支持，最重要是引入了包管理go moudle。启用go module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br></pre></td></tr></table></figure><p>初始化项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init your-project</span><br></pre></td></tr></table></figure><p>此时使用<code>go build</code>会自动下载包依赖构建。</p><p>对于被墙的包，可以设置代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><h2 id="Go-1-12"><a href="#Go-1-12" class="headerlink" title="Go 1.12"></a>Go 1.12</h2><p>该版本变化也很小</p><ul><li>GO111MODULE=on时，获取go module不再显式需要go.mod，go get 时不需要创建go.mod文件了-</li><li>添加对TLS 1.3的支持，默认不开启</li><li>go安装包中移除go tour</li></ul><h2 id="Go-1-13"><a href="#Go-1-13" class="headerlink" title="Go 1.13"></a>Go 1.13</h2><p>该版本变化也很小</p><ul><li><p><code>GO111MODULE</code>的默认值继续<code>auto</code>，但是只要当前目录包含<code>go.mod</code>文件或位于<code>go.mod</code>文件的目录下，<code>auto</code>设置就会激活go命令的模块</p></li><li><p>Go1.13这个版本引入了一个新的环境变量<code>GOPRIVATE</code>，用来指示私有的模块路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置不走proxy的私有仓库，多个用逗号相隔</span></span><br><span class="line">go env -w GOPRIVATE=*.corp.example.com</span><br></pre></td></tr></table></figure></li><li><p>1.13版本提高了<code>defer</code>性能达30%。</p></li></ul><h3 id="语言-2"><a href="#语言-2" class="headerlink" title="语言"></a>语言</h3><ul><li>新增数字表示方式0b0010 （二进制）、0o1276（八进制）、0x.8p-0（十六进制浮点）</li></ul><h3 id="核心和标准包-2"><a href="#核心和标准包-2" class="headerlink" title="核心和标准包"></a>核心和标准包</h3><h4 id="Sync-1"><a href="#Sync-1" class="headerlink" title="Sync"></a>Sync</h4><p><code>sync</code>包的<code>Once.Do</code>方法比之前快了两倍，<code>Mutex/RWMutex</code>方法的速度提高了10%。</p><h2 id="Go-1-14"><a href="#Go-1-14" class="headerlink" title="Go 1.14"></a>Go 1.14</h2><p>版本主要还是标准包的修改，语言结构上略有变化。</p><ul><li>defer性能继续提升，几乎可以忽略不计</li><li><a href="https://golang.org/pkg/time/#After" target="_blank" rel="noopener"><code>time.After</code></a>, <a href="https://golang.org/pkg/time/#Tick" target="_blank" rel="noopener"><code>time.Tick</code></a>, <a href="https://golang.org/pkg/net/#Conn" target="_blank" rel="noopener"><code>net.Conn.SetDeadline</code></a> 这些计时器修改减少资源竞争和上下文切换，性能提升</li></ul><h3 id="语言-3"><a href="#语言-3" class="headerlink" title="语言"></a>语言</h3><p>interface类型相同的方法可以覆盖了，下面的代码在1.14之前无法编译通过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">Speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">interface</span> &#123;</span><br><span class="line">Speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ChineseStudent <span class="keyword">interface</span> &#123;</span><br><span class="line">Person</span><br><span class="line">Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>1.14</code>之前版本报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./interface.go:14: duplicate method Speak</span><br></pre></td></tr></table></figure><h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><ul><li>1.14已经完全建议开发者使用go module版本管理。</li><li>go.mod 包中的<code>+incompatible</code> 标识的包本，如果模块的最新版本包含go.mod文件，则除非明确要求或已经使用该版本，否则go get将不再升级到该模块的不兼容版本。</li></ul><h3 id="核心和标准包-3"><a href="#核心和标准包-3" class="headerlink" title="核心和标准包"></a>核心和标准包</h3><h4 id="crypto-tls"><a href="#crypto-tls" class="headerlink" title="crypto/tls"></a>crypto/tls</h4><ul><li>移除SSLv3的支持</li></ul><h4 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h4><ul><li><code>StructField</code>元素添加PkgPath字段，StructOf支持创建未导出的字段。</li></ul><h4 id="hash-maphash"><a href="#hash-maphash" class="headerlink" title="hash/maphash"></a><a href="https://golang.org/pkg/hash/maphash/" target="_blank" rel="noopener">hash/maphash</a></h4><ul><li>标准库的新成员，用与字节哈希序列化，产生的结果单处理器上是一致性的，不同的处理器将产生不同结果，且不是密码安全的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker构建go程序</title>
      <link href="/2019/09/28/go-docker-builder/"/>
      <url>/2019/09/28/go-docker-builder/</url>
      
        <content type="html"><![CDATA[<p>最近公司内部Go版本需要从1.7升级到最新版，涉及项目众多。为了正式环境自动构建系统能够兼容多版本方式构建，除了使用GVM方式之外，考虑到使用Docker Go程序构建容器更加的快速，不用每次版本切换时需要重新指定GOPATH。当然升级的目的，不仅仅的性能提升，第三方包兼容等，我们也会引入Go Moudule。特此记录此次Go升级实践。</p><a id="more"></a><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>我们使用官方镜像构建自己的镜像以便后续操作。</p><p>Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最新版本构建容器</span></span><br><span class="line"><span class="keyword">FROM</span> golang:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> cheuk</span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /gobuilder</span></span><br><span class="line"><span class="comment"># SSH配置</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"StrictHostKeyChecking no"</span> &gt;&gt; /etc/ssh/ssh_config</span></span><br><span class="line"><span class="comment"># 链接替换</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> git config --global url.<span class="string">"git@gitlab.xxx.com:"</span>.insteadOf <span class="string">"http://gitlab.xxxx.com/"</span></span></span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /gobuilder</span></span><br><span class="line"><span class="comment"># 环境变量配置</span></span><br><span class="line"><span class="keyword">ENV</span> GOPATH $GOPATH:/gobuilder</span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE off</span><br><span class="line"><span class="keyword">ENV</span> GOPROXY <span class="string">""</span></span><br><span class="line"><span class="comment"># 磁盘映射package</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/gobuilder"</span>,<span class="string">"/go/src"</span>]</span></span><br></pre></td></tr></table></figure><p>SSH配置自动添加key到kown_hosts文件。Go在访问私有包的时候，请求协议为<code>http</code>，我们替换到ssh，这样能进行免密操作。</p><p>我们使用的最新版<code>latest</code>构建，创建并指定了我们的工作目录<code>/gobuilder</code>。运行构建：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t gobuilder</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">Successfully tagged gobuilder:latest</span><br></pre></td></tr></table></figure><p>构建成功，我们创建一个容器看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it gobuilder</span><br></pre></td></tr></table></figure><p>使用参数<code>-it</code>我们进入交互模式，<code>--rm</code>退出的自动删除容器。查看下go版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@3384acdd03c8:/gobuilder# go version</span><br><span class="line">go version go1.13.1 linux/amd64</span><br></pre></td></tr></table></figure><p>退出，我们映射我们的go 包文件内容到容器，启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -v ~/go/src/:/go/src gobuilder</span><br></pre></td></tr></table></figure><p><code>-v</code>将本机目录<code>~/go/src/</code>映射到容器中的/go/src目录。查看下目录下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /go/src/</span><br></pre></td></tr></table></figure><p>可以看到Go已经映射到容器。同理可以映射需要构建的项目到容器 , 并运行构建</p><h2 id="一键构建脚本"><a href="#一键构建脚本" class="headerlink" title="一键构建脚本"></a>一键构建脚本</h2><p>我们不能每次构建输入这一大串，我们写成一个脚本执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker run --rm -it \</span><br><span class="line">-v <span class="variable">$GOPATH</span>/src:/go/src \</span><br><span class="line">-v $(<span class="built_in">pwd</span>):/gobuilder \</span><br><span class="line">-v ~/.ssh/:/root/.ssh</span><br><span class="line">gobuilder /bin/sh -c <span class="string">'go mod download &amp;&amp; go build '</span><span class="string">"$*"</span></span><br></pre></td></tr></table></figure><p>这里我们映射了ssh的证书目录，这样可以共用已配置好的git正式。将脚本保存到<code>$GOPATH/bin</code>/gobuilder，修改执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x <span class="variable">$GOPATH</span>/bin/gobuilder</span><br></pre></td></tr></table></figure><p>OK，我们可以在项目目录使用我们的构建脚本了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gobuilder -o pack</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言参数传递是传值还是传引用</title>
      <link href="/2019/09/26/golang-function-params/"/>
      <url>/2019/09/26/golang-function-params/</url>
      
        <content type="html"><![CDATA[<p>Go语言参数传递是传值还是传引用？首先我们先了解下两个概念：</p><ul><li><strong>传值（Pass By Value）</strong> 函数传递的总是原来这个东西的一个副本，一副拷贝。修改拷贝不会对原对象产生影响。</li><li><strong>传引用（Pass By Reference）</strong> 函数传递的总是原来这个东西的指针引用，修改拷贝改变原对象的值。</li></ul><p>通过上面的描述，很容易让人误认为Go语言参数传递是有传值和传引用的，<strong>恰恰相反，Go语言的参数传递是没有引用的，只有传值</strong>。如果现在你脑海里有跟我一样的迷惑请往下看个例子。</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"原始值的内存地址是：%p\n"</span>, &amp;i)</span><br><span class="line">modifyInt(i)</span><br><span class="line">fmt.Println(<span class="string">"i的新值为:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyInt</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"函数里接收到的地址是：%p\n"</span>, &amp;i)</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码，输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始值的内存地址是：0xc000014088</span><br><span class="line">函数里接收到的地址是：0xc000014090</span><br><span class="line">i的新值为: 10</span><br></pre></td></tr></table></figure><p>这里的地址每次运行结果都会不一样，但是我们可以看出来，此时函数内的<code>i</code>是一份拷贝，有了一个新地址。修改他并不会影响原值。继续修改下代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"原始值的内存地址是：%p\n"</span>, &amp;i)</span><br><span class="line">modifyInt(&amp;i)</span><br><span class="line">fmt.Println(<span class="string">"i的新值为:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyInt</span><span class="params">(i *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"函数里接收到的地址是：%p\n"</span>, &amp;i)</span><br><span class="line">*i = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始值的内存地址是：0xc000082008</span><br><span class="line">函数里接收到的地址是：0xc000090010</span><br><span class="line">i的新值为: 2</span><br></pre></td></tr></table></figure><p>值改变了！不是只传值吗， 怎么现在又可以传引用？如果不幸入坑，继续往下看，首先我们来看函数参数<code>i</code>是什么类型，指针！那么<code>&amp;i</code>，没错就是<strong>指针的指针</strong>，我们打印一下<code>原始指针</code>的地址.。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"原始值的内存地址是：%p\n"</span>, &amp;i)</span><br><span class="line">ip := &amp;i</span><br><span class="line">fmt.Printf(<span class="string">"原始指针的内存地址是：%p\n"</span>, &amp;ip)</span><br><span class="line">modifyInt(ip)</span><br><span class="line">fmt.Println(<span class="string">"i的新值为:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyInt</span><span class="params">(i *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"函数里接收到的指针地址是：%p\n"</span>, &amp;i)</span><br><span class="line">*i = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始值的内存地址是：0xc000080008</span><br><span class="line">原始指针的内存地址是：0xc000090010</span><br><span class="line">函数里接收到的指针地址是：0xc00000e018</span><br><span class="line">i的新值为: 2</span><br></pre></td></tr></table></figure><p>可以看出函数中拷贝了一份新的指针，用图表示如下：</p><p><img alt="go指针" data-src="/images/goptr.png"></p><p>验证代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"原始值的内存地址是：%p\n"</span>, &amp;i)</span><br><span class="line">ip := &amp;i</span><br><span class="line">fmt.Printf(<span class="string">"原始指针的内存地址是：%p\n"</span>, &amp;ip)</span><br><span class="line">fmt.Printf(<span class="string">"原始指针实际值是：%v\n"</span>, unsafe.Pointer(ip))</span><br><span class="line">modifyInt(ip)</span><br><span class="line">fmt.Println(<span class="string">"i的新值为:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyInt</span><span class="params">(i *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"函数里接收到的指针地址是：%p\n"</span>, &amp;i)</span><br><span class="line">fmt.Printf(<span class="string">"函数里实际指针值是：%v\n"</span>, unsafe.Pointer(i))</span><br><span class="line">*i = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始值的内存地址是：0xc000088000</span><br><span class="line">原始指针的内存地址是：0xc000082018</span><br><span class="line">原始指针实际值是：0xc000088000</span><br><span class="line">函数里接收到的指针地址是：0xc000094000</span><br><span class="line">函数里实际指针值是：0xc000088000</span><br><span class="line">i的新值为: 2</span><br></pre></td></tr></table></figure><p>可以看出函数里和函数外的指针的值存储的是原始值的指针地址。</p><p>结论：<strong>Go语言参数传递是传值</strong>。需要注意的是Go中的<code>map</code>、<code>channel</code>、<code>slice</code>都隐含一项指针，传值也是把指针传进去了，所以也是会修改到原值。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令行通讯协议</title>
      <link href="/2019/09/19/redis-proto/"/>
      <url>/2019/09/19/redis-proto/</url>
      
        <content type="html"><![CDATA[<p>Redis客户端通过RESP（REdis Serialization Protocol ）协议与服务端通讯。Redis集群是则是通过另一协议来处理节点间的通讯。</p><p>RESP有以下特点：</p><ul><li>简单且容易实现</li><li>能够快速解析</li><li>可读的</li></ul><p>RESP 能够序列化各种类型，包括整形，字符串，数组，错误类型. 客户端连接服务端的数据是以字符串数组的形式发送给服务端，相当于命令的参数形式。Redis 响应命令执行结果数据.</p><p>RESP 是二进制安全的，不需要从一个进程传送大量的数据，因为使用了前缀长度（prefixed-length）传送数据。</p><a id="more"></a><h2 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h2><p>二进制化的字符串,不关心具体格式.只会严格的按照二进制的数据存取。不会妄图已某种特殊格式解析数据。也就是二进制安全的字符串是只有一种正确解。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>Redis使用TCP进行客户端的连接，但是技术上不完全依赖TCP，更像是 Unix sockets</p><h2 id="Unix-sockets"><a href="#Unix-sockets" class="headerlink" title="Unix sockets"></a>Unix sockets</h2><p>Unix Domain Socket 是在Socket架构上发展起来的用于同一台主机的进程间通讯（IPC）。它不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序列号应答等。只是将应用层数据从一个进程拷贝到另一个进程。Unix Domain Socket有SOKCET_DGRAM和SOCKET_STREAM两种模式，类似于UDP和TCP，但是面向消息的Unix socket也是可靠的，消息既不会丢失也不会顺序错乱。比如的mysql socket文件：<code>/tmp/mysql.sock</code>, 直接操作该文件就可以与mysql通讯。</p><h2 id="请求响应模型"><a href="#请求响应模型" class="headerlink" title="请求响应模型"></a>请求响应模型</h2><p>Redis使用的是最简单的协议，接收一个命令参数时，会立即执行该命令并返回执行结果数据。</p><p>除以下情况，Redis都是通过这种简单协议通讯:</p><ul><li>Redis 支持管道操作。导致一次性会有很多的命令发送后需要等待返回</li><li>Redis订阅了一个Pub/Sub 频道，redis将更改协议语义，此时转变成了push协议。客服端不在发送指令，而是由服务端发送数据到客户端。</li></ul><h2 id="RESP-协议描述"><a href="#RESP-协议描述" class="headerlink" title="RESP 协议描述"></a>RESP 协议描述</h2><p>RESP实际上就是一个序列化协议。支持简单字符串、错误、整形，批量字符串和数组类型。</p><p>Redis 的请求响应协议方式有以下两种:</p><ul><li>所有客户端发送到服务端的命令都是一个字符串数组.</li><li>Redis根据指令的执行结果，回复一个相应的数据类型</li></ul><p>RESP 通过第一个个字节来标记数据类型:</p><ul><li><code>+</code> 标记字符串</li><li><code>-</code> 标记错误类型</li><li><code>:</code> 标记整形</li><li><code>$</code> 标记批量字符串</li><li><code>*</code> 标记数据类型</li></ul><p>RESP 总是以<code>\r\n</code> (CRLF)为结束符。</p><h2 id="简单字符串"><a href="#简单字符串" class="headerlink" title="简单字符串"></a>简单字符串</h2><p>简单字符串,及非二进制安全的字符串。使用<code>+</code> 开始标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;+OK\r\n&quot;</span><br></pre></td></tr></table></figure><p>如果要发送二进制安全的字符串，则需要通过字符串数组方式。</p><h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>与简单字符串类似，不过是以<code>-</code>开头。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;-Error message\r\n&quot;</span><br></pre></td></tr></table></figure><p>只有在发生错误时才会返回错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-ERR unknown command &apos;foobar&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p><code>ERR</code>，<code>WRONGTYPE</code> 是错误类型前缀，以便区分不同的错误类型，<code>ERR</code>是基本的错误类型。</p><h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><p>以<code>:</code>开头，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;:0\r\n&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;:1000\r\n&quot;</span><br></pre></td></tr></table></figure><p>多用与<code>INCR</code>,<code>LLEN</code>,<code>LASTSAVE</code>等命令。整形的<code>1</code>,<code>0</code>可以用来表示真假。也可以用来表示指令是否成功执行</p><h2 id="字符串数组（Bulk-Strings）"><a href="#字符串数组（Bulk-Strings）" class="headerlink" title="字符串数组（Bulk Strings）"></a>字符串数组（Bulk Strings）</h2><p>用来传送二进制安全的字符串，高达512M长度的发送。</p><p>通过以下方式进行编码：</p><ul><li>以<code>$</code>开头接收一个长度的数字,拼接上CFLR<code>\r\n</code></li><li>再次连接实际的字符串</li><li>以CFLR结束<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$6\r\nfoobar\r\n&quot;</span><br></pre></td></tr></table></figure></li></ul><p>特别的空表示方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$0\r\n\r\n&quot;</span><br></pre></td></tr></table></figure><p>Null表示方式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$-1\r\n&quot;</span><br></pre></td></tr></table></figure><p>以上两种特别情况下，不同的API库不会返回一个可空的字符串，不同语言的封装包，中例如Ruby返回nil对象，C语言放回Null。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>LRANGE</code> 命令返回的就是数组格式。</p><p>通过以下方式格式化：</p><ul><li><p>以<code>*</code>开头跟上数组的长度，以CRLF结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;*0\r\n&quot;</span><br></pre></td></tr></table></figure></li><li><p>数组元素是可选的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n&quot;</span><br></pre></td></tr></table></figure></li></ul><p>表示两个数组，由两个字符串<code>$3\r\nfoo\r\n</code>,<code>$3\r\nbar\r\n</code>组成。<br>数据可以进行类型混合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*5\r\n</span><br><span class="line">:1\r\n</span><br><span class="line">:2\r\n</span><br><span class="line">:3\r\n</span><br><span class="line">:4\r\n</span><br><span class="line">$6\r\n</span><br><span class="line">foobar\r\n</span><br></pre></td></tr></table></figure><p>为了清晰可见这里做了换行处理。</p><p>特别的，Null数组表示方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;*-1\r\n&quot;</span><br></pre></td></tr></table></figure><p>数组的元素支持Null，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n</span><br><span class="line">$3\r\n</span><br><span class="line">foo\r\n</span><br><span class="line">$-1\r\n</span><br><span class="line">$3\r\n</span><br><span class="line">bar\r\n</span><br></pre></td></tr></table></figure><p>为了清晰可见这里做了换行处理。不同语言包处理的结果不同，可能是一下结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"foo"</span>,<span class="keyword">null</span>,<span class="string">"bar"</span>]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"foo"</span>,<span class="literal">nil</span>,<span class="string">"bar"</span>]</span><br></pre></td></tr></table></figure><h2 id="原理实践"><a href="#原理实践" class="headerlink" title="原理实践"></a>原理实践</h2><ul><li>客服端发送字符串数组到服务端</li><li>服务端根据实际执行结果返回内容</li></ul><p>如果我们要执行<code>LLEN mylist</code><br>则客户端发送:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2\r\n</span><br><span class="line">$4\r\n</span><br><span class="line">LLEN\r\n</span><br><span class="line">$6\r\n</span><br><span class="line">mylist\r\n</span><br></pre></td></tr></table></figure><p>为了清晰可见这里做了换行处理,实际上发送的不能进行换行处理，实际发送内容是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n</span><br></pre></td></tr></table></figure><p>服务端返回:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;:3445\r\n&quot;</span><br></pre></td></tr></table></figure><h3 id="多命令管道化"><a href="#多命令管道化" class="headerlink" title="多命令管道化"></a>多命令管道化</h3><p>客户端可以在一个连接上提交多个命令，管道提供了一个可以一次提交多个命令的方法。</p><h3 id="内联命令"><a href="#内联命令" class="headerlink" title="内联命令"></a>内联命令</h3><p>如果我们手头上的没有redis-cli工具，只有<code>telnet</code>或者单纯的其他TCP连接工具，那么我么可以使用内联命令使用redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>输入PING</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">PING</span><br><span class="line">+PONG</span><br></pre></td></tr></table></figure><p>例如可输入得到结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXISTS somekey</span><br><span class="line">:0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
